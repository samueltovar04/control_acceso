{"remainingRequest":"C:\\Lagash\\Projects\\control\\control_web\\src\\main\\web\\node_modules\\@angular-devkit\\build-optimizer\\src\\build-optimizer\\webpack-loader.js??ref--3-1!C:\\Lagash\\Projects\\control\\control_web\\src\\main\\web\\node_modules\\ngx-webcam\\fesm5\\ngx-webcam.js","dependencies":[{"path":"C:\\Lagash\\Projects\\control\\control_web\\src\\main\\web\\node_modules\\ngx-webcam\\fesm5\\ngx-webcam.js","mtime":499162500000},{"path":"C:\\Lagash\\Projects\\control\\control_web\\src\\main\\web\\node_modules\\cache-loader\\dist\\cjs.js","mtime":499162500000},{"path":"C:\\Lagash\\Projects\\control\\control_web\\src\\main\\web\\node_modules\\@angular-devkit\\build-optimizer\\src\\build-optimizer\\webpack-loader.js","mtime":1519266497000}],"contextDependencies":[],"result":["import { __decorate, __metadata } from 'tslib';\nimport { Input, Output, EventEmitter, ViewChild, Component, NgModule } from '@angular/core';\nimport { CommonModule } from '@angular/common';\nimport { Observable } from 'rxjs';\n/**\n * Container class for a captured webcam image\n * @author basst314, davidshen84\n */\nvar WebcamImage = /*@__PURE__*/ (function () {\n    function WebcamImage(imageAsDataUrl, mimeType, imageData) {\n        this._mimeType = null;\n        this._imageAsBase64 = null;\n        this._imageAsDataUrl = null;\n        this._imageData = null;\n        this._mimeType = mimeType;\n        this._imageAsDataUrl = imageAsDataUrl;\n        this._imageData = imageData;\n    }\n    /**\n     * Extracts the Base64 data out of the given dataUrl.\n     * @param dataUrl the given dataUrl\n     * @param mimeType the mimeType of the data\n     */\n    WebcamImage.getDataFromDataUrl = function (dataUrl, mimeType) {\n        return dataUrl.replace(\"data:\" + mimeType + \";base64,\", '');\n    };\n    Object.defineProperty(WebcamImage.prototype, \"imageAsBase64\", {\n        /**\n         * Get the base64 encoded image data\n         * @returns base64 data of the image\n         */\n        get: function () {\n            return this._imageAsBase64 ? this._imageAsBase64\n                : this._imageAsBase64 = WebcamImage.getDataFromDataUrl(this._imageAsDataUrl, this._mimeType);\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(WebcamImage.prototype, \"imageAsDataUrl\", {\n        /**\n         * Get the encoded image as dataUrl\n         * @returns the dataUrl of the image\n         */\n        get: function () {\n            return this._imageAsDataUrl;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(WebcamImage.prototype, \"imageData\", {\n        /**\n         * Get the ImageData object associated with the canvas' 2d context.\n         * @returns the ImageData of the canvas's 2d context.\n         */\n        get: function () {\n            return this._imageData;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    return WebcamImage;\n}());\nvar WebcamUtil = /*@__PURE__*/ (function () {\n    function WebcamUtil() {\n    }\n    /**\n     * Lists available videoInput devices\n     * @returns a list of media device info.\n     */\n    WebcamUtil.getAvailableVideoInputs = function () {\n        if (!navigator.mediaDevices || !navigator.mediaDevices.enumerateDevices) {\n            return Promise.reject('enumerateDevices() not supported.');\n        }\n        return new Promise(function (resolve, reject) {\n            navigator.mediaDevices.enumerateDevices()\n                .then(function (devices) {\n                resolve(devices.filter(function (device) { return device.kind === 'videoinput'; }));\n            })\n                .catch(function (err) {\n                reject(err.message || err);\n            });\n        });\n    };\n    return WebcamUtil;\n}());\nvar WebcamComponent = /*@__PURE__*/ (function () {\n    function WebcamComponent() {\n        /** Defines the max width of the webcam area in px */\n        this.width = 640;\n        /** Defines the max height of the webcam area in px */\n        this.height = 480;\n        /** Defines base constraints to apply when requesting video track from UserMedia */\n        this.videoOptions = WebcamComponent_1.DEFAULT_VIDEO_OPTIONS;\n        /** Flag to enable/disable camera switch. If enabled, a switch icon will be displayed if multiple cameras were found */\n        this.allowCameraSwitch = true;\n        /** Flag to control whether an ImageData object is stored into the WebcamImage object. */\n        this.captureImageData = false;\n        /** The image type to use when capturing snapshots */\n        this.imageType = WebcamComponent_1.DEFAULT_IMAGE_TYPE;\n        /** The image quality to use when capturing snapshots (number between 0 and 1) */\n        this.imageQuality = WebcamComponent_1.DEFAULT_IMAGE_QUALITY;\n        /** EventEmitter which fires when an image has been captured */\n        this.imageCapture = new EventEmitter();\n        /** Emits a mediaError if webcam cannot be initialized (e.g. missing user permissions) */\n        this.initError = new EventEmitter();\n        /** Emits when the webcam video was clicked */\n        this.imageClick = new EventEmitter();\n        /** Emits the active deviceId after the active video device was switched */\n        this.cameraSwitched = new EventEmitter();\n        /** available video devices */\n        this.availableVideoInputs = [];\n        /** Indicates whether the video device is ready to be switched */\n        this.videoInitialized = false;\n        /** Index of active video in availableVideoInputs */\n        this.activeVideoInputIndex = -1;\n        /** MediaStream object in use for streaming UserMedia data */\n        this.mediaStream = null;\n        /** width and height of the active video stream */\n        this.activeVideoSettings = null;\n    }\n    WebcamComponent_1 = WebcamComponent;\n    Object.defineProperty(WebcamComponent.prototype, \"trigger\", {\n        /**\n         * If the given Observable emits, an image will be captured and emitted through 'imageCapture' EventEmitter\n         */\n        set: function (trigger) {\n            var _this = this;\n            if (this.triggerSubscription) {\n                this.triggerSubscription.unsubscribe();\n            }\n            // Subscribe to events from this Observable to take snapshots\n            this.triggerSubscription = trigger.subscribe(function () {\n                _this.takeSnapshot();\n            });\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(WebcamComponent.prototype, \"switchCamera\", {\n        /**\n         * If the given Observable emits, the active webcam will be switched to the one indicated by the emitted value.\n         * @param switchCamera Indicates which webcam to switch to\n         *   true: cycle forwards through available webcams\n         *   false: cycle backwards through available webcams\n         *   string: activate the webcam with the given id\n         */\n        set: function (switchCamera) {\n            var _this = this;\n            if (this.switchCameraSubscription) {\n                this.switchCameraSubscription.unsubscribe();\n            }\n            // Subscribe to events from this Observable to switch video device\n            this.switchCameraSubscription = switchCamera.subscribe(function (value) {\n                if (typeof value === 'string') {\n                    // deviceId was specified\n                    _this.switchToVideoInput(value);\n                }\n                else {\n                    // direction was specified\n                    _this.rotateVideoInput(value !== false);\n                }\n            });\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * Get MediaTrackConstraints to request streaming the given device\n     * @param deviceId\n     * @param baseMediaTrackConstraints base constraints to merge deviceId-constraint into\n     * @returns\n     */\n    WebcamComponent.getMediaConstraintsForDevice = function (deviceId, baseMediaTrackConstraints) {\n        var result = baseMediaTrackConstraints ? baseMediaTrackConstraints : this.DEFAULT_VIDEO_OPTIONS;\n        if (deviceId) {\n            result.deviceId = { exact: deviceId };\n        }\n        return result;\n    };\n    /**\n     * Tries to harvest the deviceId from the given mediaStreamTrack object.\n     * Browsers populate this object differently; this method tries some different approaches\n     * to read the id.\n     * @param mediaStreamTrack\n     * @returns deviceId if found in the mediaStreamTrack\n     */\n    WebcamComponent.getDeviceIdFromMediaStreamTrack = function (mediaStreamTrack) {\n        if (mediaStreamTrack.getSettings && mediaStreamTrack.getSettings() && mediaStreamTrack.getSettings().deviceId) {\n            return mediaStreamTrack.getSettings().deviceId;\n        }\n        else if (mediaStreamTrack.getConstraints && mediaStreamTrack.getConstraints() && mediaStreamTrack.getConstraints().deviceId) {\n            var deviceIdObj = mediaStreamTrack.getConstraints().deviceId;\n            return WebcamComponent_1.getValueFromConstrainDOMString(deviceIdObj);\n        }\n    };\n    /**\n     * Tries to harvest the facingMode from the given mediaStreamTrack object.\n     * Browsers populate this object differently; this method tries some different approaches\n     * to read the value.\n     * @param mediaStreamTrack\n     * @returns facingMode if found in the mediaStreamTrack\n     */\n    WebcamComponent.getFacingModeFromMediaStreamTrack = function (mediaStreamTrack) {\n        if (mediaStreamTrack) {\n            if (mediaStreamTrack.getSettings && mediaStreamTrack.getSettings() && mediaStreamTrack.getSettings().facingMode) {\n                return mediaStreamTrack.getSettings().facingMode;\n            }\n            else if (mediaStreamTrack.getConstraints && mediaStreamTrack.getConstraints() && mediaStreamTrack.getConstraints().facingMode) {\n                var facingModeConstraint = mediaStreamTrack.getConstraints().facingMode;\n                return WebcamComponent_1.getValueFromConstrainDOMString(facingModeConstraint);\n            }\n        }\n    };\n    /**\n     * Determines whether the given mediaStreamTrack claims itself as user facing\n     * @param mediaStreamTrack\n     */\n    WebcamComponent.isUserFacing = function (mediaStreamTrack) {\n        var facingMode = WebcamComponent_1.getFacingModeFromMediaStreamTrack(mediaStreamTrack);\n        return facingMode ? 'user' === facingMode.toLowerCase() : false;\n    };\n    /**\n     * Extracts the value from the given ConstrainDOMString\n     * @param constrainDOMString\n     */\n    WebcamComponent.getValueFromConstrainDOMString = function (constrainDOMString) {\n        if (constrainDOMString) {\n            if (constrainDOMString instanceof String) {\n                return String(constrainDOMString);\n            }\n            else if (Array.isArray(constrainDOMString) && Array(constrainDOMString).length > 0) {\n                return String(constrainDOMString[0]);\n            }\n            else if (typeof constrainDOMString === 'object') {\n                if (constrainDOMString['exact']) {\n                    return String(constrainDOMString['exact']);\n                }\n                else if (constrainDOMString['ideal']) {\n                    return String(constrainDOMString['ideal']);\n                }\n            }\n        }\n        return null;\n    };\n    WebcamComponent.prototype.ngAfterViewInit = function () {\n        var _this = this;\n        this.detectAvailableDevices()\n            .then(function () {\n            // start video\n            _this.switchToVideoInput(null);\n        })\n            .catch(function (err) {\n            _this.initError.next({ message: err });\n            // fallback: still try to load webcam, even if device enumeration failed\n            _this.switchToVideoInput(null);\n        });\n    };\n    WebcamComponent.prototype.ngOnDestroy = function () {\n        this.stopMediaTracks();\n        this.unsubscribeFromSubscriptions();\n    };\n    /**\n     * Takes a snapshot of the current webcam's view and emits the image as an event\n     */\n    WebcamComponent.prototype.takeSnapshot = function () {\n        // set canvas size to actual video size\n        var _video = this.nativeVideoElement;\n        var dimensions = { width: this.width, height: this.height };\n        if (_video.videoWidth) {\n            dimensions.width = _video.videoWidth;\n            dimensions.height = _video.videoHeight;\n        }\n        var _canvas = this.canvas.nativeElement;\n        _canvas.width = dimensions.width;\n        _canvas.height = dimensions.height;\n        // paint snapshot image to canvas\n        var context2d = _canvas.getContext('2d');\n        context2d.drawImage(_video, 0, 0);\n        // read canvas content as image\n        var mimeType = this.imageType ? this.imageType : WebcamComponent_1.DEFAULT_IMAGE_TYPE;\n        var quality = this.imageQuality ? this.imageQuality : WebcamComponent_1.DEFAULT_IMAGE_QUALITY;\n        var dataUrl = _canvas.toDataURL(mimeType, quality);\n        // get the ImageData object from the canvas' context.\n        var imageData = null;\n        if (this.captureImageData) {\n            imageData = context2d.getImageData(0, 0, _canvas.width, _canvas.height);\n        }\n        this.imageCapture.next(new WebcamImage(dataUrl, mimeType, imageData));\n    };\n    /**\n     * Switches to the next/previous video device\n     * @param forward\n     */\n    WebcamComponent.prototype.rotateVideoInput = function (forward) {\n        if (this.availableVideoInputs && this.availableVideoInputs.length > 1) {\n            var increment = forward ? 1 : (this.availableVideoInputs.length - 1);\n            var nextInputIndex = (this.activeVideoInputIndex + increment) % this.availableVideoInputs.length;\n            this.switchToVideoInput(this.availableVideoInputs[nextInputIndex].deviceId);\n        }\n    };\n    /**\n     * Switches the camera-view to the specified video device\n     */\n    WebcamComponent.prototype.switchToVideoInput = function (deviceId) {\n        this.videoInitialized = false;\n        this.stopMediaTracks();\n        this.initWebcam(deviceId, this.videoOptions);\n    };\n    /**\n     * Event-handler for video resize event.\n     * Triggers Angular change detection so that new video dimensions get applied\n     */\n    WebcamComponent.prototype.videoResize = function () {\n        // here to trigger Angular change detection\n    };\n    Object.defineProperty(WebcamComponent.prototype, \"videoWidth\", {\n        get: function () {\n            var videoRatio = this.getVideoAspectRatio();\n            return Math.min(this.width, this.height * videoRatio);\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(WebcamComponent.prototype, \"videoHeight\", {\n        get: function () {\n            var videoRatio = this.getVideoAspectRatio();\n            return Math.min(this.height, this.width / videoRatio);\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(WebcamComponent.prototype, \"videoStyleClasses\", {\n        get: function () {\n            var classes = '';\n            if (this.isMirrorImage()) {\n                classes += 'mirrored ';\n            }\n            return classes.trim();\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(WebcamComponent.prototype, \"nativeVideoElement\", {\n        get: function () {\n            return this.video.nativeElement;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * Returns the video aspect ratio of the active video stream\n     */\n    WebcamComponent.prototype.getVideoAspectRatio = function () {\n        // calculate ratio from video element dimensions if present\n        var videoElement = this.nativeVideoElement;\n        if (videoElement.videoWidth && videoElement.videoWidth > 0 &&\n            videoElement.videoHeight && videoElement.videoHeight > 0) {\n            return videoElement.videoWidth / videoElement.videoHeight;\n        }\n        // nothing present - calculate ratio based on width/height params\n        return this.width / this.height;\n    };\n    /**\n     * Init webcam live view\n     */\n    WebcamComponent.prototype.initWebcam = function (deviceId, userVideoTrackConstraints) {\n        var _this = this;\n        var _video = this.nativeVideoElement;\n        if (navigator.mediaDevices && navigator.mediaDevices.getUserMedia) {\n            // merge deviceId -> userVideoTrackConstraints\n            var videoTrackConstraints = WebcamComponent_1.getMediaConstraintsForDevice(deviceId, userVideoTrackConstraints);\n            navigator.mediaDevices.getUserMedia({ video: videoTrackConstraints })\n                .then(function (stream) {\n                _this.mediaStream = stream;\n                _video.srcObject = stream;\n                _video.play();\n                _this.activeVideoSettings = stream.getVideoTracks()[0].getSettings();\n                var activeDeviceId = WebcamComponent_1.getDeviceIdFromMediaStreamTrack(stream.getVideoTracks()[0]);\n                _this.cameraSwitched.next(activeDeviceId);\n                // Initial detect may run before user gave permissions, returning no deviceIds. This prevents later camera switches. (#47)\n                // Run detect once again within getUserMedia callback, to make sure this time we have permissions and get deviceIds.\n                _this.detectAvailableDevices()\n                    .then(function () {\n                    _this.activeVideoInputIndex = activeDeviceId ? _this.availableVideoInputs\n                        .findIndex(function (mediaDeviceInfo) { return mediaDeviceInfo.deviceId === activeDeviceId; }) : -1;\n                    _this.videoInitialized = true;\n                })\n                    .catch(function () {\n                    _this.activeVideoInputIndex = -1;\n                    _this.videoInitialized = true;\n                });\n            })\n                .catch(function (err) {\n                _this.initError.next({ message: err.message, mediaStreamError: err });\n            });\n        }\n        else {\n            this.initError.next({ message: 'Cannot read UserMedia from MediaDevices.' });\n        }\n    };\n    WebcamComponent.prototype.getActiveVideoTrack = function () {\n        return this.mediaStream ? this.mediaStream.getVideoTracks()[0] : null;\n    };\n    WebcamComponent.prototype.isMirrorImage = function () {\n        if (!this.getActiveVideoTrack()) {\n            return false;\n        }\n        // check for explicit mirror override parameter\n        {\n            var mirror = 'auto';\n            if (this.mirrorImage) {\n                if (typeof this.mirrorImage === 'string') {\n                    mirror = String(this.mirrorImage).toLowerCase();\n                }\n                else {\n                    // WebcamMirrorProperties\n                    if (this.mirrorImage.x) {\n                        mirror = this.mirrorImage.x.toLowerCase();\n                    }\n                }\n            }\n            switch (mirror) {\n                case 'always':\n                    return true;\n                case 'never':\n                    return false;\n            }\n        }\n        // default: enable mirroring if webcam is user facing\n        return WebcamComponent_1.isUserFacing(this.getActiveVideoTrack());\n    };\n    /**\n     * Stops all active media tracks.\n     * This prevents the webcam from being indicated as active,\n     * even if it is no longer used by this component.\n     */\n    WebcamComponent.prototype.stopMediaTracks = function () {\n        if (this.mediaStream && this.mediaStream.getTracks) {\n            // getTracks() returns all media tracks (video+audio)\n            this.mediaStream.getTracks()\n                .forEach(function (track) { return track.stop(); });\n        }\n    };\n    /**\n     * Unsubscribe from all open subscriptions\n     */\n    WebcamComponent.prototype.unsubscribeFromSubscriptions = function () {\n        if (this.triggerSubscription) {\n            this.triggerSubscription.unsubscribe();\n        }\n        if (this.switchCameraSubscription) {\n            this.switchCameraSubscription.unsubscribe();\n        }\n    };\n    /**\n     * Reads available input devices\n     */\n    WebcamComponent.prototype.detectAvailableDevices = function () {\n        var _this = this;\n        return new Promise(function (resolve, reject) {\n            WebcamUtil.getAvailableVideoInputs()\n                .then(function (devices) {\n                _this.availableVideoInputs = devices;\n                resolve(devices);\n            })\n                .catch(function (err) {\n                _this.availableVideoInputs = [];\n                reject(err);\n            });\n        });\n    };\n    var WebcamComponent_1;\n    WebcamComponent.DEFAULT_VIDEO_OPTIONS = { facingMode: 'environment' };\n    WebcamComponent.DEFAULT_IMAGE_TYPE = 'image/jpeg';\n    WebcamComponent.DEFAULT_IMAGE_QUALITY = 0.92;\n    return WebcamComponent;\n}());\nvar COMPONENTS = [\n    WebcamComponent\n];\nvar WebcamModule = /*@__PURE__*/ (function () {\n    function WebcamModule() {\n    }\n    return WebcamModule;\n}());\nvar WebcamInitError = /*@__PURE__*/ (function () {\n    function WebcamInitError() {\n        this.message = null;\n        this.mediaStreamError = null;\n    }\n    return WebcamInitError;\n}());\nvar WebcamMirrorProperties = /*@__PURE__*/ (function () {\n    function WebcamMirrorProperties() {\n    }\n    return WebcamMirrorProperties;\n}());\nexport { WebcamComponent, WebcamImage, WebcamInitError, WebcamMirrorProperties, WebcamModule, WebcamUtil };\n//# sourceMappingURL=ngx-webcam.js.map\n",null]}
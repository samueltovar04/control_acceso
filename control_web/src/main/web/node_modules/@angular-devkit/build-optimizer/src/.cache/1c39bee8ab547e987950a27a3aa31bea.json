{"remainingRequest":"C:\\Lagash\\Projects\\control\\control_web\\src\\main\\web\\node_modules\\@angular-devkit\\build-optimizer\\src\\build-optimizer\\webpack-loader.js??ref--3-1!C:\\Lagash\\Projects\\control\\control_web\\src\\main\\web\\node_modules\\rxjs\\observable\\IntervalObservable.js","dependencies":[{"path":"C:\\Lagash\\Projects\\control\\control_web\\src\\main\\web\\node_modules\\rxjs\\observable\\IntervalObservable.js","mtime":499162500000},{"path":"C:\\Lagash\\Projects\\control\\control_web\\src\\main\\web\\node_modules\\cache-loader\\dist\\cjs.js","mtime":499162500000},{"path":"C:\\Lagash\\Projects\\control\\control_web\\src\\main\\web\\node_modules\\@angular-devkit\\build-optimizer\\src\\build-optimizer\\webpack-loader.js","mtime":1519266497000}],"contextDependencies":[],"result":["\"use strict\";\r\nvar __extends = /*@__PURE__*/ require(\"tslib\").__extends;\r\nvar isNumeric_1 = require('../util/isNumeric');\r\nvar Observable_1 = require('../Observable');\r\nvar async_1 = require('../scheduler/async');\r\n/**\r\n * We need this JSDoc comment for affecting ESDoc.\r\n * @extends {Ignored}\r\n * @hide true\r\n */\r\nvar IntervalObservable = /*@__PURE__*/ (function (_super) {\r\n    __extends(IntervalObservable, _super);\r\n    function IntervalObservable(period, scheduler) {\r\n        if (period === void 0) {\r\n            period = 0;\r\n        }\r\n        if (scheduler === void 0) {\r\n            scheduler = async_1.async;\r\n        }\r\n        _super.call(this);\r\n        this.period = period;\r\n        this.scheduler = scheduler;\r\n        if (!isNumeric_1.isNumeric(period) || period < 0) {\r\n            this.period = 0;\r\n        }\r\n        if (!scheduler || typeof scheduler.schedule !== 'function') {\r\n            this.scheduler = async_1.async;\r\n        }\r\n    }\r\n    /**\r\n     * Creates an Observable that emits sequential numbers every specified\r\n     * interval of time, on a specified IScheduler.\r\n     *\r\n     * <span class=\"informal\">Emits incremental numbers periodically in time.\r\n     * </span>\r\n     *\r\n     * <img src=\"./img/interval.png\" width=\"100%\">\r\n     *\r\n     * `interval` returns an Observable that emits an infinite sequence of\r\n     * ascending integers, with a constant interval of time of your choosing\r\n     * between those emissions. The first emission is not sent immediately, but\r\n     * only after the first period has passed. By default, this operator uses the\r\n     * `async` IScheduler to provide a notion of time, but you may pass any\r\n     * IScheduler to it.\r\n     *\r\n     * @example <caption>Emits ascending numbers, one every second (1000ms)</caption>\r\n     * var numbers = Rx.Observable.interval(1000);\r\n     * numbers.subscribe(x => console.log(x));\r\n     *\r\n     * @see {@link timer}\r\n     * @see {@link delay}\r\n     *\r\n     * @param {number} [period=0] The interval size in milliseconds (by default)\r\n     * or the time unit determined by the scheduler's clock.\r\n     * @param {Scheduler} [scheduler=async] The IScheduler to use for scheduling\r\n     * the emission of values, and providing a notion of \"time\".\r\n     * @return {Observable} An Observable that emits a sequential number each time\r\n     * interval.\r\n     * @static true\r\n     * @name interval\r\n     * @owner Observable\r\n     */\r\n    IntervalObservable.create = function (period, scheduler) {\r\n        if (period === void 0) {\r\n            period = 0;\r\n        }\r\n        if (scheduler === void 0) {\r\n            scheduler = async_1.async;\r\n        }\r\n        return new IntervalObservable(period, scheduler);\r\n    };\r\n    IntervalObservable.dispatch = function (state) {\r\n        var index = state.index, subscriber = state.subscriber, period = state.period;\r\n        subscriber.next(index);\r\n        if (subscriber.closed) {\r\n            return;\r\n        }\r\n        state.index += 1;\r\n        this.schedule(state, period);\r\n    };\r\n    /** @deprecated internal use only */ IntervalObservable.prototype._subscribe = function (subscriber) {\r\n        var index = 0;\r\n        var period = this.period;\r\n        var scheduler = this.scheduler;\r\n        subscriber.add(scheduler.schedule(IntervalObservable.dispatch, period, {\r\n            index: index, subscriber: subscriber, period: period\r\n        }));\r\n    };\r\n    return IntervalObservable;\r\n}(Observable_1.Observable));\r\nexports.IntervalObservable = IntervalObservable;\r\n",null]}
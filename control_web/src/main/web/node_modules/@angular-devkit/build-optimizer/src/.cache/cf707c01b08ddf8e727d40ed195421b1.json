{"remainingRequest":"C:\\Lagash\\Projects\\control\\control_web\\src\\main\\web\\node_modules\\@angular-devkit\\build-optimizer\\src\\build-optimizer\\webpack-loader.js??ref--3-1!C:\\Lagash\\Projects\\control\\control_web\\src\\main\\web\\node_modules\\angular-bootstrap-md\\fesm5\\angular-bootstrap-md.js","dependencies":[{"path":"C:\\Lagash\\Projects\\control\\control_web\\src\\main\\web\\node_modules\\angular-bootstrap-md\\fesm5\\angular-bootstrap-md.js","mtime":499162500000},{"path":"C:\\Lagash\\Projects\\control\\control_web\\src\\main\\web\\node_modules\\cache-loader\\dist\\cjs.js","mtime":499162500000},{"path":"C:\\Lagash\\Projects\\control\\control_web\\src\\main\\web\\node_modules\\@angular-devkit\\build-optimizer\\src\\build-optimizer\\webpack-loader.js","mtime":1519266497000}],"contextDependencies":[],"result":["import { state, style, trigger, transition, animate } from '@angular/animations';\nimport { NG_VALUE_ACCESSOR, FormsModule, NG_VALIDATORS } from '@angular/forms';\nimport { RouterLinkWithHref } from '@angular/router';\nimport { CommonModule, isPlatformBrowser } from '@angular/common';\nimport { __values, __decorate, __metadata, __read, __assign } from 'tslib';\nimport { Component, ElementRef, HostBinding, Input, Renderer2, ViewEncapsulation, NgModule, Directive, HostListener, forwardRef, ChangeDetectionStrategy, ViewChild, Injectable, ChangeDetectorRef, ContentChildren, EventEmitter, Inject, Output, PLATFORM_ID, Injector, TemplateRef, RendererFactory2, ApplicationRef, ComponentFactoryResolver, NgZone, ViewContainerRef, Attribute, NO_ERRORS_SCHEMA, ContentChild, ɵɵdefineInjectable } from '@angular/core';\nimport { Subject, timer, fromEvent, merge, of, animationFrameScheduler, Observable } from 'rxjs';\nimport { take, distinctUntilChanged, filter, map, pairwise, share, skip, throttleTime } from 'rxjs/operators';\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\nvar MDBBadgeComponent = /*@__PURE__*/ (function () {\n    function MDBBadgeComponent(_el, _renderer) {\n        this._el = _el;\n        this._renderer = _renderer;\n    }\n    /**\n     * @return {?}\n     */\n    MDBBadgeComponent.prototype.ngOnInit = /**\n     * @return {?}\n     */\n        function () {\n            var _this = this;\n            this._renderer.addClass(this._el.nativeElement, 'badge');\n            if (this.color) {\n                /** @type {?} */\n                var customClassArr = this.color.split(' ');\n                customClassArr.forEach((function (el) {\n                    _this._renderer.addClass(_this._el.nativeElement, el);\n                }));\n            }\n        };\n    return MDBBadgeComponent;\n}());\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\nvar BadgeModule = /*@__PURE__*/ (function () {\n    function BadgeModule() {\n    }\n    return BadgeModule;\n}());\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\nvar MdbBreadcrumbComponent = /*@__PURE__*/ (function () {\n    function MdbBreadcrumbComponent() {\n    }\n    return MdbBreadcrumbComponent;\n}());\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\nvar MdbBreadcrumbItemComponent = /*@__PURE__*/ (function () {\n    function MdbBreadcrumbItemComponent(_el, _renderer) {\n        this._el = _el;\n        this._renderer = _renderer;\n    }\n    /**\n     * @return {?}\n     */\n    MdbBreadcrumbItemComponent.prototype.ngOnInit = /**\n     * @return {?}\n     */\n        function () {\n            this._renderer.addClass(this._el.nativeElement, 'breadcrumb-item');\n        };\n    return MdbBreadcrumbItemComponent;\n}());\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\nvar BreadcrumbModule = /*@__PURE__*/ (function () {\n    function BreadcrumbModule() {\n    }\n    return BreadcrumbModule;\n}());\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\nvar MdbBtnDirective = /*@__PURE__*/ (function () {\n    function MdbBtnDirective(el, renderer) {\n        this.el = el;\n        this.renderer = renderer;\n        this.color = '';\n        this.rounded = false;\n        this.gradient = '';\n        this.outline = false;\n        this.flat = false;\n        this.size = '';\n        this.block = false;\n        this.floating = false;\n    }\n    /**\n     * @return {?}\n     */\n    MdbBtnDirective.prototype.ngOnInit = /**\n     * @return {?}\n     */\n        function () {\n            /** @type {?} */\n            var colorClass = 'btn-' + this.color;\n            /** @type {?} */\n            var gradientClass = this.gradient + '-gradient';\n            /** @type {?} */\n            var outlineClass = 'btn-outline-' + this.color;\n            /** @type {?} */\n            var flatClass = 'btn-flat';\n            /** @type {?} */\n            var roundedClass = 'btn-rounded';\n            /** @type {?} */\n            var sizeClass = 'btn-' + this.size;\n            /** @type {?} */\n            var blockClass = 'btn-block';\n            /** @type {?} */\n            var floatingClass = 'btn-floating';\n            this.renderer.addClass(this.el.nativeElement, 'btn');\n            if (this.color !== '') {\n                this.renderer.addClass(this.el.nativeElement, colorClass);\n            }\n            if (this.rounded) {\n                this.renderer.addClass(this.el.nativeElement, roundedClass);\n            }\n            if (this.gradient) {\n                if (this.color !== '') {\n                    this.renderer.removeClass(this.el.nativeElement, colorClass);\n                }\n                this.renderer.addClass(this.el.nativeElement, gradientClass);\n            }\n            if (this.outline) {\n                this.renderer.removeClass(this.el.nativeElement, colorClass);\n                this.renderer.addClass(this.el.nativeElement, outlineClass);\n            }\n            if (this.flat) {\n                if (this.color) {\n                    this.renderer.removeClass(this.el.nativeElement, colorClass);\n                }\n                if (this.gradient) {\n                    this.renderer.removeClass(this.el.nativeElement, gradientClass);\n                }\n                if (this.outline) {\n                    this.renderer.removeClass(this.el.nativeElement, outlineClass);\n                }\n                if (this.rounded) {\n                    this.renderer.removeClass(this.el.nativeElement, roundedClass);\n                }\n                this.renderer.addClass(this.el.nativeElement, flatClass);\n            }\n            if (this.size) {\n                this.renderer.addClass(this.el.nativeElement, sizeClass);\n            }\n            if (this.block) {\n                this.renderer.addClass(this.el.nativeElement, blockClass);\n            }\n            if (this.floating) {\n                this.renderer.removeClass(this.el.nativeElement, 'btn');\n                this.renderer.addClass(this.el.nativeElement, floatingClass);\n            }\n        };\n    return MdbBtnDirective;\n}());\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n// TODO: config: activeClass - Class to apply to the checked buttons\n/** @type {?} */\nvar CHECKBOX_CONTROL_VALUE_ACCESSOR = {\n    provide: NG_VALUE_ACCESSOR,\n    // tslint:disable-next-line: no-use-before-declare\n    useExisting: forwardRef((function () { return ButtonCheckboxDirective; })),\n    multi: true,\n};\n/**\n * Add checkbox functionality to any element\n */\nvar ButtonCheckboxDirective = /*@__PURE__*/ (function () {\n    function ButtonCheckboxDirective() {\n        /**\n         * Truthy value, will be set to ngModel\n         */\n        this.btnCheckboxTrue = true;\n        /**\n         * Falsy value, will be set to ngModel\n         */\n        this.btnCheckboxFalse = false;\n        this.state = false;\n        this.onChange = Function.prototype;\n        this.onTouched = Function.prototype;\n    }\n    // view -> model\n    // view -> model\n    /**\n     * @return {?}\n     */\n    ButtonCheckboxDirective.prototype.onClick =\n        // view -> model\n        /**\n         * @return {?}\n         */\n        function () {\n            if (this.isDisabled) {\n                return;\n            }\n            this.toggle(!this.state);\n            this.onChange(this.value);\n        };\n    /**\n     * @return {?}\n     */\n    ButtonCheckboxDirective.prototype.ngOnInit = /**\n     * @return {?}\n     */\n        function () {\n            this.toggle(this.trueValue === this.value);\n        };\n    Object.defineProperty(ButtonCheckboxDirective.prototype, \"trueValue\", {\n        get: /**\n         * @protected\n         * @return {?}\n         */ function () {\n            return typeof this.btnCheckboxTrue !== 'undefined' ? this.btnCheckboxTrue : true;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(ButtonCheckboxDirective.prototype, \"falseValue\", {\n        get: /**\n         * @protected\n         * @return {?}\n         */ function () {\n            return typeof this.btnCheckboxFalse !== 'undefined' ? this.btnCheckboxFalse : false;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * @param {?} state\n     * @return {?}\n     */\n    ButtonCheckboxDirective.prototype.toggle = /**\n     * @param {?} state\n     * @return {?}\n     */\n        function (state$$1) {\n            this.state = state$$1;\n            this.value = this.state ? this.trueValue : this.falseValue;\n        };\n    // ControlValueAccessor\n    // model -> view\n    // ControlValueAccessor\n    // model -> view\n    /**\n     * @param {?} value\n     * @return {?}\n     */\n    ButtonCheckboxDirective.prototype.writeValue =\n        // ControlValueAccessor\n        // model -> view\n        /**\n         * @param {?} value\n         * @return {?}\n         */\n        function (value) {\n            this.state = this.trueValue === value;\n            this.value = value ? this.trueValue : this.falseValue;\n        };\n    /**\n     * @param {?} isDisabled\n     * @return {?}\n     */\n    ButtonCheckboxDirective.prototype.setDisabledState = /**\n     * @param {?} isDisabled\n     * @return {?}\n     */\n        function (isDisabled) {\n            this.isDisabled = isDisabled;\n        };\n    /**\n     * @param {?} fn\n     * @return {?}\n     */\n    ButtonCheckboxDirective.prototype.registerOnChange = /**\n     * @param {?} fn\n     * @return {?}\n     */\n        function (fn) {\n            this.onChange = fn;\n        };\n    /**\n     * @param {?} fn\n     * @return {?}\n     */\n    ButtonCheckboxDirective.prototype.registerOnTouched = /**\n     * @param {?} fn\n     * @return {?}\n     */\n        function (fn) {\n            this.onTouched = fn;\n        };\n    return ButtonCheckboxDirective;\n}());\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/** @type {?} */\nvar RADIO_CONTROL_VALUE_ACCESSOR = {\n    provide: NG_VALUE_ACCESSOR,\n    // tslint:disable-next-line: no-use-before-declare\n    useExisting: forwardRef((function () { return ButtonRadioDirective; })),\n    multi: true,\n};\n/**\n * Create radio buttons or groups of buttons.\n * A value of a selected button is bound to a variable specified via ngModel.\n */\nvar ButtonRadioDirective = /*@__PURE__*/ (function () {\n    function ButtonRadioDirective(el, renderer) {\n        this.renderer = renderer;\n        this.onChange = Function.prototype;\n        this.onTouched = Function.prototype;\n        this.radioElementsArray = [];\n        this.el = el;\n    }\n    Object.defineProperty(ButtonRadioDirective.prototype, \"isActive\", {\n        get: /**\n         * @return {?}\n         */ function () {\n            return this.mdbRadio === this.value;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    // @HostBinding('class.active')\n    // @HostBinding('class.active')\n    /**\n     * @param {?=} event\n     * @return {?}\n     */\n    ButtonRadioDirective.prototype.onClick =\n        // @HostBinding('class.active')\n        /**\n         * @param {?=} event\n         * @return {?}\n         */\n        function (event) {\n            var _this = this;\n            try {\n                this.el.nativeElement.parentElement.childNodes.forEach((function (element) {\n                    _this.radioElementsArray.push(element);\n                }));\n                this.radioElementsArray.forEach((function (element) {\n                    _this.renderer.removeClass(element, 'active');\n                }));\n                this.renderer.addClass(event.target, 'active');\n            }\n            catch (error) { }\n            if (this.el.nativeElement.attributes.disabled) {\n                return;\n            }\n            if (this.uncheckable && this.mdbRadio === this.value) {\n                this.value = undefined;\n            }\n            else {\n                this.value = this.mdbRadio;\n            }\n            this.onTouched();\n            this.onChange(this.value);\n        };\n    /**\n     * @return {?}\n     */\n    ButtonRadioDirective.prototype.ngOnInit = /**\n     * @return {?}\n     */\n        function () {\n            this.uncheckable = typeof this.uncheckable !== 'undefined';\n        };\n    /**\n     * @return {?}\n     */\n    ButtonRadioDirective.prototype.onBlur = /**\n     * @return {?}\n     */\n        function () {\n            this.onTouched();\n        };\n    // ControlValueAccessor\n    // model -> view\n    // ControlValueAccessor\n    // model -> view\n    /**\n     * @param {?} value\n     * @return {?}\n     */\n    ButtonRadioDirective.prototype.writeValue =\n        // ControlValueAccessor\n        // model -> view\n        /**\n         * @param {?} value\n         * @return {?}\n         */\n        function (value) {\n            this.value = value;\n        };\n    /**\n     * @param {?} fn\n     * @return {?}\n     */\n    ButtonRadioDirective.prototype.registerOnChange = /**\n     * @param {?} fn\n     * @return {?}\n     */\n        function (fn) {\n            this.onChange = fn;\n        };\n    /**\n     * @param {?} fn\n     * @return {?}\n     */\n    ButtonRadioDirective.prototype.registerOnTouched = /**\n     * @param {?} fn\n     * @return {?}\n     */\n        function (fn) {\n            this.onTouched = fn;\n        };\n    return ButtonRadioDirective;\n}());\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\nvar FixedButtonCaptionDirective = /*@__PURE__*/ (function () {\n    function FixedButtonCaptionDirective(renderer, el) {\n        this.renderer = renderer;\n        this.el = el;\n    }\n    /**\n     * @return {?}\n     */\n    FixedButtonCaptionDirective.prototype.ngOnInit = /**\n     * @return {?}\n     */\n        function () {\n            this.createCaptionElement();\n        };\n    /**\n     * @return {?}\n     */\n    FixedButtonCaptionDirective.prototype.createCaptionElement = /**\n     * @return {?}\n     */\n        function () {\n            /** @type {?} */\n            var paragraph = this.renderer.createElement('p');\n            /** @type {?} */\n            var text = this.renderer.createText(this.caption);\n            this.renderer.appendChild(paragraph, text);\n            this.renderer.appendChild(this.el.nativeElement, paragraph);\n            this.paragraphEl = paragraph;\n        };\n    /**\n     * @return {?}\n     */\n    FixedButtonCaptionDirective.prototype.showCaption = /**\n     * @return {?}\n     */\n        function () {\n            this.renderer.addClass(this.paragraphEl, 'fixed-button-caption');\n            this.renderer.setStyle(this.paragraphEl, 'position', 'absolute');\n            this.renderer.setStyle(this.paragraphEl, 'right', \"60px\");\n            this.renderer.setStyle(this.paragraphEl, 'top', '10px');\n            this.renderer.setStyle(this.el.nativeElement, 'overflow', 'visible');\n        };\n    return FixedButtonCaptionDirective;\n}());\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\nvar ButtonsModule = /*@__PURE__*/ (function () {\n    function ButtonsModule() {\n    }\n    /**\n     * @return {?}\n     */\n    ButtonsModule.forRoot = /**\n     * @return {?}\n     */\n        function () {\n            return { ngModule: ButtonsModule, providers: [] };\n        };\n    return ButtonsModule;\n}());\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\nvar MdbCardFooterComponent = /*@__PURE__*/ (function () {\n    // @Input() class: string;\n    function MdbCardFooterComponent(_el, _r) {\n        this._el = _el;\n        this._r = _r;\n    }\n    /**\n     * @return {?}\n     */\n    MdbCardFooterComponent.prototype.ngOnInit = /**\n     * @return {?}\n     */\n        function () {\n            this._r.addClass(this._el.nativeElement, 'card-footer');\n            // if (this.class) {\n            //     this.class.split(' ').forEach((element: any) => {\n            //         this._r.addClass(this._el.nativeElement, element);\n            //     });\n            // }\n        };\n    return MdbCardFooterComponent;\n}());\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\nvar MdbCardTitleComponent = /*@__PURE__*/ (function () {\n    function MdbCardTitleComponent(_el, _r) {\n        this._el = _el;\n        this._r = _r;\n    }\n    /**\n     * @return {?}\n     */\n    MdbCardTitleComponent.prototype.ngOnInit = /**\n     * @return {?}\n     */\n        function () {\n            this._r.addClass(this._el.nativeElement, 'card-title');\n        };\n    return MdbCardTitleComponent;\n}());\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\nvar MdbCardTextComponent = /*@__PURE__*/ (function () {\n    function MdbCardTextComponent() {\n    }\n    return MdbCardTextComponent;\n}());\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\nvar MdbCardBodyComponent = /*@__PURE__*/ (function () {\n    function MdbCardBodyComponent(_el, _r) {\n        this._el = _el;\n        this._r = _r;\n    }\n    Object.defineProperty(MdbCardBodyComponent.prototype, \"cascade\", {\n        set: /**\n         * @param {?} cascade\n         * @return {?}\n         */ function (cascade) {\n            if (cascade) {\n                this._r.addClass(this._el.nativeElement, 'card-body-cascade');\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * @return {?}\n     */\n    MdbCardBodyComponent.prototype.ngOnInit = /**\n     * @return {?}\n     */\n        function () {\n            var _this = this;\n            this._r.addClass(this._el.nativeElement, 'card-body');\n            if (this.class) {\n                this.class.split(' ').forEach((function (element) {\n                    _this._r.addClass(_this._el.nativeElement, element);\n                }));\n            }\n        };\n    return MdbCardBodyComponent;\n}());\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\nvar MdbCardComponent = /*@__PURE__*/ (function () {\n    function MdbCardComponent(_el, _r) {\n        this._el = _el;\n        this._r = _r;\n    }\n    Object.defineProperty(MdbCardComponent.prototype, \"narrower\", {\n        set: /**\n         * @param {?} narrower\n         * @return {?}\n         */ function (narrower) {\n            if (narrower) {\n                this._r.addClass(this._el.nativeElement, 'narrower');\n            }\n            else if (!narrower && this._el.nativeElement.classList.contains('narrower')) {\n                this._r.removeClass(this._el.nativeElement, 'narrower');\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(MdbCardComponent.prototype, \"reverse\", {\n        set: /**\n         * @param {?} reverse\n         * @return {?}\n         */ function (reverse) {\n            if (reverse) {\n                this._r.addClass(this._el.nativeElement, 'reverse');\n            }\n            else if (!reverse && this._el.nativeElement.classList.contains('reserse')) {\n                this._r.removeClass(this._el.nativeElement, 'reverse');\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(MdbCardComponent.prototype, \"dark\", {\n        set: /**\n         * @param {?} dark\n         * @return {?}\n         */ function (dark) {\n            if (dark) {\n                this._r.addClass(this._el.nativeElement, 'card-dark');\n            }\n            else if (!dark && this._el.nativeElement.classList.contains('card-dard')) {\n                this._r.removeClass(this._el.nativeElement, 'card-dark');\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(MdbCardComponent.prototype, \"bgColor\", {\n        set: /**\n         * @param {?} color\n         * @return {?}\n         */ function (color) {\n            if (color) {\n                this._r.addClass(this._el.nativeElement, color);\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(MdbCardComponent.prototype, \"borderColor\", {\n        set: /**\n         * @param {?} color\n         * @return {?}\n         */ function (color) {\n            if (color) {\n                this._r.addClass(this._el.nativeElement, color);\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * @return {?}\n     */\n    MdbCardComponent.prototype.ngOnInit = /**\n     * @return {?}\n     */\n        function () {\n            var _this = this;\n            this._r.addClass(this._el.nativeElement, 'card');\n            if (this.cascade) {\n                this._r.addClass(this._el.nativeElement, 'card-cascade');\n            }\n            if (this.wider) {\n                this._r.addClass(this._el.nativeElement, 'wider');\n            }\n            if (this.narrower) {\n                this._r.addClass(this._el.nativeElement, 'narrower');\n            }\n            if (this.class) {\n                this.class.split(' ').forEach((function (element) {\n                    _this._r.addClass(_this._el.nativeElement, element);\n                }));\n            }\n            if (this._el.nativeElement.parentElement.classList.contains('card-deck')) {\n                this._r.addClass(this._el.nativeElement, 'w-100');\n                this._r.addClass(this._el.nativeElement, 'mx-0');\n            }\n        };\n    return MdbCardComponent;\n}());\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\nvar MdbCardImageComponent = /*@__PURE__*/ (function () {\n    function MdbCardImageComponent() {\n    }\n    return MdbCardImageComponent;\n}());\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\nvar MdbCardHeaderComponent = /*@__PURE__*/ (function () {\n    function MdbCardHeaderComponent(_el, _r) {\n        this._el = _el;\n        this._r = _r;\n    }\n    /**\n     * @return {?}\n     */\n    MdbCardHeaderComponent.prototype.ngOnInit = /**\n     * @return {?}\n     */\n        function () {\n            var _this = this;\n            this._r.addClass(this._el.nativeElement, 'card-header');\n            if (this.class) {\n                this.class.split(' ').forEach((function (element) {\n                    _this._r.addClass(_this._el.nativeElement, element);\n                }));\n            }\n        };\n    return MdbCardHeaderComponent;\n}());\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\nvar CardsModule = /*@__PURE__*/ (function () {\n    function CardsModule() {\n    }\n    /**\n     * @return {?}\n     */\n    CardsModule.forRoot = /**\n     * @return {?}\n     */\n        function () {\n            return { ngModule: CardsModule, providers: [] };\n        };\n    return CardsModule;\n}());\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/*tslint:disable */\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * JS version of browser APIs. This library can only run in the browser.\n * @type {?}\n */\nvar win = typeof window !== 'undefined' && window || (({}));\n/** @type {?} */\nvar document$1 = win.document;\n/** @type {?} */\nvar location = win.location;\n/** @type {?} */\nvar gc = win['gc'] ? (function () { return win['gc'](); }) : (function () { return null; });\n/** @type {?} */\nvar performance = win['performance'] ? win['performance'] : null;\n/** @type {?} */\nvar Event = win['Event'];\n/** @type {?} */\nvar MouseEvent = win['MouseEvent'];\n/** @type {?} */\nvar KeyboardEvent = win['KeyboardEvent'];\n/** @type {?} */\nvar EventTarget = win['EventTarget'];\n/** @type {?} */\nvar History = win['History'];\n/** @type {?} */\nvar Location = win['Location'];\n/** @type {?} */\nvar EventListener = win['EventListener'];\n/** @type {?} */\nvar navigator$1 = win['navigator'];\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * @return {?}\n */\nfunction isBs3() {\n    return win.__theme === 'bs4';\n}\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n// import { CarouselComponent } from './carousel.component';\nvar SlideComponent = /*@__PURE__*/ (function () {\n    function SlideComponent(el) {\n        this.animated = false;\n        this.directionNext = false;\n        this.directionLeft = false;\n        this.directionPrev = false;\n        this.directionRight = false;\n        /**\n         * Wraps element by appropriate CSS classes\n         */\n        this.el = null;\n        // this.carousel = carousel;\n        this.el = el;\n    }\n    /** Fires changes in container collection after adding a new slide instance */\n    /**\n     * Fires changes in container collection after adding a new slide instance\n     * @return {?}\n     */\n    SlideComponent.prototype.ngOnInit = /**\n     * Fires changes in container collection after adding a new slide instance\n     * @return {?}\n     */\n        function () {\n            // this.carousel.addSlide(this);\n        };\n    /** Fires changes in container collection after removing of this slide instance */\n    /**\n     * Fires changes in container collection after removing of this slide instance\n     * @return {?}\n     */\n    SlideComponent.prototype.ngOnDestroy = /**\n     * Fires changes in container collection after removing of this slide instance\n     * @return {?}\n     */\n        function () {\n            // this.carousel.removeSlide(this);\n        };\n    return SlideComponent;\n}());\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\nvar CarouselConfig = /*@__PURE__*/ (function () {\n    function CarouselConfig() {\n        /**\n         * Default interval of auto changing of slides\n         */\n        this.interval = 5000;\n        /**\n         * Is loop of auto changing of slides can be paused\n         */\n        this.noPause = false;\n        /**\n         * Is slides can wrap from the last to the first slide\n         */\n        this.noWrap = false;\n        this.keyboard = false;\n    }\n    return CarouselConfig;\n}());\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/** @enum {number} */\nvar Direction = /*@__PURE__*/ (function () {\n    var Direction = {\n        UNKNOWN: 0,\n        NEXT: 1,\n        PREV: 2,\n    };\n    Direction[Direction.UNKNOWN] = 'UNKNOWN';\n    Direction[Direction.NEXT] = 'NEXT';\n    Direction[Direction.PREV] = 'PREV';\n    return Direction;\n}());\n/**\n * Base element to create carousel\n */\nvar CarouselComponent = /*@__PURE__*/ (function () {\n    function CarouselComponent(config, el, platformId, cdRef, renderer) {\n        this.cdRef = cdRef;\n        this.renderer = renderer;\n        this.SWIPE_ACTION = { LEFT: 'swipeleft', RIGHT: 'swiperight' };\n        this.destroyed = false;\n        this.el = null;\n        this.animationEnd = true;\n        this.isBrowser = false;\n        this.isControls = true;\n        this.class = '';\n        this.type = '';\n        this.animation = '';\n        this.activeSlideChange = new EventEmitter(false);\n        this.isBrowser = isPlatformBrowser(platformId);\n        Object.assign(this, config);\n        this.el = el;\n    }\n    Object.defineProperty(CarouselComponent.prototype, \"slides\", {\n        get: /**\n         * @return {?}\n         */ function () {\n            return this._slidesList.toArray();\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(CarouselComponent.prototype, \"activeSlide\", {\n        get: /**\n         * @return {?}\n         */ function () {\n            return this._currentActiveSlide;\n        },\n        set: /**\n         * @param {?} index\n         * @return {?}\n         */ function (index) {\n            if (this._slidesList && index !== this._currentActiveSlide) {\n                this._select(index);\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * @return {?}\n     */\n    CarouselComponent.prototype.checkNavigation = /**\n     * @return {?}\n     */\n        function () {\n            if (this.type === 'carousel-multi-item') {\n                return false;\n            }\n            return true;\n        };\n    /**\n     * @return {?}\n     */\n    CarouselComponent.prototype.checkDots = /**\n     * @return {?}\n     */\n        function () {\n            if (this.type === 'carousel-thumbnails') {\n                return false;\n            }\n            return true;\n        };\n    /**\n     * @param {?} slide\n     * @return {?}\n     */\n    CarouselComponent.prototype.getImg = /**\n     * @param {?} slide\n     * @return {?}\n     */\n        function (slide) {\n            return slide.el.nativeElement.querySelector('img').src;\n        };\n    Object.defineProperty(CarouselComponent.prototype, \"interval\", {\n        get: /**\n         * @return {?}\n         */ function () {\n            return this._interval;\n        },\n        set: /**\n         * @param {?} value\n         * @return {?}\n         */ function (value) {\n            this._interval = value;\n            this.restartTimer();\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(CarouselComponent.prototype, \"isBs4\", {\n        get: /**\n         * @return {?}\n         */ function () {\n            return !isBs3();\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * @return {?}\n     */\n    CarouselComponent.prototype.ngOnDestroy = /**\n     * @return {?}\n     */\n        function () {\n            this.destroyed = true;\n        };\n    /**\n     * @return {?}\n     */\n    CarouselComponent.prototype.ngAfterViewInit = /**\n     * @return {?}\n     */\n        function () {\n            var _this = this;\n            this.play();\n            this._slidesList.changes.subscribe((function (slidesList) {\n                _this._slidesList = slidesList;\n                setTimeout((function () {\n                    _this._select(0);\n                }), 0);\n            }));\n            if (this.activeSlideIndex) {\n                setTimeout((function () {\n                    _this._select(_this.activeSlideIndex);\n                    _this.activeSlideChange.emit({ relatedTarget: _this.activeSlide });\n                }), 0);\n            }\n            else {\n                setTimeout((function () {\n                    _this._select(0);\n                }), 0);\n            }\n            if (this.isControls) {\n                this.carouselIndicators = this.el.nativeElement.querySelectorAll('.carousel-indicators > li');\n                if (this.carouselIndicators.length && this.activeSlideIndex) {\n                    this.renderer.addClass(this.carouselIndicators[this.activeSlideIndex], 'active');\n                }\n                else if (this.carouselIndicators.length) {\n                    this.renderer.addClass(this.carouselIndicators[0], 'active');\n                }\n            }\n        };\n    /**\n     * @param {?=} action\n     * @return {?}\n     */\n    CarouselComponent.prototype.swipe = /**\n     * @param {?=} action\n     * @return {?}\n     */\n        function (action) {\n            if (action === void 0) {\n                action = this.SWIPE_ACTION.RIGHT;\n            }\n            if (action === this.SWIPE_ACTION.RIGHT) {\n                this.previousSlide();\n                this.cdRef.markForCheck();\n            }\n            if (action === this.SWIPE_ACTION.LEFT) {\n                this.nextSlide();\n                this.cdRef.markForCheck();\n            }\n        };\n    /**\n     * @param {?=} force\n     * @return {?}\n     */\n    CarouselComponent.prototype.nextSlide = /**\n     * @param {?=} force\n     * @return {?}\n     */\n        function (force) {\n            if (force === void 0) {\n                force = false;\n            }\n            if (this.animation === 'slide') {\n                this.pause();\n                /** @type {?} */\n                var direction = Direction.NEXT;\n                this.slideAnimation(this.findNextSlideIndex(direction, force), direction);\n                this.cdRef.markForCheck();\n            }\n            else if (this.animation === 'fade') {\n                this.pause();\n                this.fadeAnimation(this.findNextSlideIndex(Direction.NEXT, force), Direction.NEXT);\n                this.cdRef.markForCheck();\n            }\n            else {\n                this.activeSlide = this.findNextSlideIndex(Direction.NEXT, force);\n                this.cdRef.markForCheck();\n            }\n            if (!this.animation) {\n                this.activeSlideChange.emit({ direction: 'Next', relatedTarget: this.activeSlide });\n            }\n        };\n    /**\n     * @param {?=} force\n     * @return {?}\n     */\n    CarouselComponent.prototype.previousSlide = /**\n     * @param {?=} force\n     * @return {?}\n     */\n        function (force) {\n            if (force === void 0) {\n                force = false;\n            }\n            if (this.animation === 'slide') {\n                this.pause();\n                /** @type {?} */\n                var direction = Direction.PREV;\n                this.slideAnimation(this.findNextSlideIndex(direction, force), direction);\n                this.cdRef.markForCheck();\n            }\n            else if (this.animation === 'fade') {\n                this.pause();\n                this.fadeAnimation(this.findNextSlideIndex(Direction.PREV, force), Direction.PREV);\n                this.cdRef.markForCheck();\n            }\n            else {\n                this.activeSlide = this.findNextSlideIndex(Direction.PREV, force);\n                this.cdRef.markForCheck();\n            }\n            if (!this.animation) {\n                this.activeSlideChange.emit({ direction: 'Prev', relatedTarget: this.activeSlide });\n            }\n        };\n    /**\n     * @protected\n     * @param {?} goToIndex\n     * @param {?=} direction\n     * @return {?}\n     */\n    CarouselComponent.prototype.fadeAnimation = /**\n     * @protected\n     * @param {?} goToIndex\n     * @param {?=} direction\n     * @return {?}\n     */\n        function (goToIndex, direction) {\n            var _this = this;\n            /** @type {?} */\n            var goToSlide = this.slides[goToIndex];\n            if (this.animationEnd) {\n                this.animationEnd = false;\n                goToSlide.directionNext = true;\n                if (this.isBrowser) {\n                    setTimeout((function () {\n                        /** @type {?} */\n                        var previous = _this.slides[_this._currentActiveSlide].el.nativeElement;\n                        _this.renderer.setStyle(previous, 'opacity', '0');\n                        _this.renderer.setStyle(previous, 'transition', 'all 600ms');\n                        _this.renderer.setStyle(previous, 'display', 'block');\n                        _this.renderer.setStyle(goToSlide.el.nativeElement, 'display', 'block');\n                        _this.renderer.setStyle(goToSlide.el.nativeElement, 'opacity', '1');\n                        _this.renderer.setStyle(goToSlide.el.nativeElement, 'transition', 'all 600ms');\n                        if (direction === 1) {\n                            _this.activeSlideChange.emit({ direction: 'Next', relatedTarget: _this.activeSlide });\n                        }\n                        else if (direction === 2) {\n                            _this.activeSlideChange.emit({ direction: 'Prev', relatedTarget: _this.activeSlide });\n                        }\n                        goToSlide.directionNext = false;\n                        _this.animationEnd = true;\n                        _this.activeSlide = goToIndex;\n                        _this.activeSlideChange.emit({ direction: 'Next', relatedTarget: _this.activeSlide });\n                        _this.play();\n                        _this.cdRef.markForCheck();\n                    }), 0);\n                }\n            }\n        };\n    /**\n     * @protected\n     * @param {?} goToIndex\n     * @param {?} direction\n     * @return {?}\n     */\n    CarouselComponent.prototype.slideAnimation = /**\n     * @protected\n     * @param {?} goToIndex\n     * @param {?} direction\n     * @return {?}\n     */\n        function (goToIndex, direction) {\n            var _this = this;\n            /** @type {?} */\n            var currentSlide = this.slides[this._currentActiveSlide];\n            /** @type {?} */\n            var goToSlide = this.slides[goToIndex];\n            if (this.animationEnd) {\n                if (direction === Direction.NEXT) {\n                    this.animationEnd = false;\n                    goToSlide.directionNext = true;\n                    if (this.isBrowser) {\n                        setTimeout((function () {\n                            goToSlide.directionLeft = true;\n                            currentSlide.directionLeft = true;\n                            _this.cdRef.markForCheck();\n                        }), 100);\n                    }\n                }\n                if (direction === Direction.PREV) {\n                    this.animationEnd = false;\n                    goToSlide.directionPrev = true;\n                    if (this.isBrowser) {\n                        setTimeout((function () {\n                            goToSlide.directionRight = true;\n                            currentSlide.directionRight = true;\n                            _this.cdRef.markForCheck();\n                        }), 100);\n                    }\n                }\n                if (this.isBrowser) {\n                    setTimeout((function () {\n                        goToSlide.directionLeft = false;\n                        goToSlide.directionNext = false;\n                        currentSlide.directionLeft = false;\n                        currentSlide.directionNext = false;\n                        goToSlide.directionRight = false;\n                        goToSlide.directionPrev = false;\n                        currentSlide.directionRight = false;\n                        currentSlide.directionPrev = false;\n                        _this.animationEnd = true;\n                        _this.activeSlide = goToIndex;\n                        /** @type {?} */\n                        var directionName;\n                        if (direction === Direction.NEXT) {\n                            directionName = 'Next';\n                        }\n                        else if (direction === Direction.PREV) {\n                            directionName = 'Prev';\n                        }\n                        _this.activeSlideChange.emit({\n                            direction: directionName,\n                            relatedTarget: _this.activeSlide,\n                        });\n                        _this.play();\n                        _this.cdRef.markForCheck();\n                    }), 700);\n                }\n            }\n        };\n    /**\n     * @param {?} index\n     * @return {?}\n     */\n    CarouselComponent.prototype.selectSlide = /**\n     * @param {?} index\n     * @return {?}\n     */\n        function (index) {\n            this.pause();\n            if (this.animation === 'slide') {\n                if (this.activeSlide < index) {\n                    this.slideAnimation(index, Direction.NEXT);\n                }\n                else if (this.activeSlide > index) {\n                    this.slideAnimation(index, Direction.PREV);\n                }\n            }\n            else if (this.animation === 'fade') {\n                if (index !== this.activeSlide) {\n                    this.fadeAnimation(index);\n                }\n            }\n            this.play();\n        };\n    /**\n     * @return {?}\n     */\n    CarouselComponent.prototype.play = /**\n     * @return {?}\n     */\n        function () {\n            if (!this.isPlaying) {\n                this.isPlaying = true;\n                this.restartTimer();\n            }\n        };\n    /**\n     * @return {?}\n     */\n    CarouselComponent.prototype.pause = /**\n     * @return {?}\n     */\n        function () {\n            if (!this.noPause) {\n                this.isPlaying = false;\n                this.resetTimer();\n            }\n        };\n    /**\n     * @return {?}\n     */\n    CarouselComponent.prototype.getCurrentSlideIndex = /**\n     * @return {?}\n     */\n        function () {\n            return this.slides.findIndex((function (slide) { return slide.active; }));\n        };\n    /**\n     * @param {?} index\n     * @return {?}\n     */\n    CarouselComponent.prototype.isLast = /**\n     * @param {?} index\n     * @return {?}\n     */\n        function (index) {\n            return index + 1 >= this.slides.length;\n        };\n    /**\n     * @private\n     * @param {?} direction\n     * @param {?} force\n     * @return {?}\n     */\n    CarouselComponent.prototype.findNextSlideIndex = /**\n     * @private\n     * @param {?} direction\n     * @param {?} force\n     * @return {?}\n     */\n        function (direction, force) {\n            /** @type {?} */\n            var nextSlideIndex = 0;\n            if (!force && (this.isLast(this.activeSlide) && direction !== Direction.PREV && this.noWrap)) {\n                return void 0;\n            }\n            switch (direction) {\n                case Direction.NEXT:\n                    nextSlideIndex = !this.isLast(this._currentActiveSlide)\n                        ? this._currentActiveSlide + 1\n                        : !force && this.noWrap\n                            ? this._currentActiveSlide\n                            : 0;\n                    break;\n                case Direction.PREV:\n                    nextSlideIndex =\n                        this._currentActiveSlide > 0\n                            ? this._currentActiveSlide - 1\n                            : !force && this.noWrap\n                                ? this._currentActiveSlide\n                                : this.slides.length - 1;\n                    break;\n                default:\n                    throw new Error('Unknown direction');\n            }\n            return nextSlideIndex;\n        };\n    /**\n     * @private\n     * @param {?} index\n     * @return {?}\n     */\n    CarouselComponent.prototype._select = /**\n     * @private\n     * @param {?} index\n     * @return {?}\n     */\n        function (index) {\n            if (isNaN(index)) {\n                this.pause();\n                return;\n            }\n            /** @type {?} */\n            var currentSlide = this.slides[this._currentActiveSlide];\n            if (currentSlide) {\n                currentSlide.active = false;\n            }\n            /** @type {?} */\n            var nextSlide = this.slides[index];\n            if (nextSlide) {\n                this._currentActiveSlide = index;\n                nextSlide.active = true;\n                this.activeSlide = index;\n            }\n        };\n    /**\n     * @private\n     * @return {?}\n     */\n    CarouselComponent.prototype.restartTimer = /**\n     * @private\n     * @return {?}\n     */\n        function () {\n            var _this = this;\n            this.resetTimer();\n            if (this.isBrowser) {\n                /** @type {?} */\n                var interval = +this.interval;\n                if (!isNaN(interval) && interval > 0) {\n                    this.currentInterval = setInterval((function () {\n                        /** @type {?} */\n                        var nInterval = +_this.interval;\n                        if (_this.isPlaying && !isNaN(_this.interval) && nInterval > 0 && _this.slides.length) {\n                            _this.nextSlide();\n                        }\n                        else {\n                            _this.pause();\n                        }\n                    }), interval);\n                }\n            }\n        };\n    /**\n     * @private\n     * @return {?}\n     */\n    CarouselComponent.prototype.resetTimer = /**\n     * @private\n     * @return {?}\n     */\n        function () {\n            if (this.isBrowser) {\n                if (this.currentInterval) {\n                    clearInterval(this.currentInterval);\n                    this.currentInterval = void 0;\n                }\n            }\n        };\n    /**\n     * @protected\n     * @param {?} el\n     * @param {?} className\n     * @return {?}\n     */\n    CarouselComponent.prototype.hasClass = /**\n     * @protected\n     * @param {?} el\n     * @param {?} className\n     * @return {?}\n     */\n        function (el, className) {\n            if (el.classList) {\n                return el.classList.contains(className);\n            }\n            else {\n                return !!el.className.match(new RegExp('(\\\\s|^)' + className + '(\\\\s|$)'));\n            }\n        };\n    /**\n     * @protected\n     * @param {?} el\n     * @param {?} className\n     * @return {?}\n     */\n    CarouselComponent.prototype.classAdd = /**\n     * @protected\n     * @param {?} el\n     * @param {?} className\n     * @return {?}\n     */\n        function (el, className) {\n            if (el.classList) {\n                el.classList.add(className);\n            }\n            else if (!this.hasClass(el, className)) {\n                el.className += ' ' + className;\n            }\n        };\n    /**\n     * @protected\n     * @param {?} el\n     * @param {?} className\n     * @return {?}\n     */\n    CarouselComponent.prototype.removeClass = /**\n     * @protected\n     * @param {?} el\n     * @param {?} className\n     * @return {?}\n     */\n        function (el, className) {\n            if (el.classList) {\n                el.classList.remove(className);\n            }\n            else if (this.hasClass(el, className)) {\n                /** @type {?} */\n                var reg = new RegExp('(\\\\s|^)' + className + '(\\\\s|$)');\n                el.className = el.className.replace(reg, ' ');\n            }\n        };\n    /**\n     * @param {?} event\n     * @return {?}\n     */\n    CarouselComponent.prototype.keyboardControl = /**\n     * @param {?} event\n     * @return {?}\n     */\n        function (event) {\n            if (this.keyboard) {\n                // tslint:disable-next-line: deprecation\n                if (event.keyCode === 39) {\n                    this.nextSlide();\n                }\n                // tslint:disable-next-line: deprecation\n                if (event.keyCode === 37) {\n                    this.previousSlide();\n                }\n            }\n        };\n    /**\n     * @return {?}\n     */\n    CarouselComponent.prototype.focus = /**\n     * @return {?}\n     */\n        function () {\n            this.el.nativeElement.focus();\n        };\n    return CarouselComponent;\n}());\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\nvar CarouselModule = /*@__PURE__*/ (function () {\n    function CarouselModule() {\n    }\n    /**\n     * @return {?}\n     */\n    CarouselModule.forRoot = /**\n     * @return {?}\n     */\n        function () {\n            return { ngModule: CarouselModule, providers: [] };\n        };\n    return CarouselModule;\n}());\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\nvar BaseChartDirective = /*@__PURE__*/ (function () {\n    function BaseChartDirective(element, platformId) {\n        this.labels = [];\n        this.options = {\n            legend: { display: false },\n        };\n        this.legend = false;\n        this.chartClick = new EventEmitter();\n        this.chartHover = new EventEmitter();\n        this.initFlag = false;\n        this.isBrowser = false;\n        this.element = element;\n        this.isBrowser = isPlatformBrowser(platformId);\n    }\n    /**\n     * @return {?}\n     */\n    BaseChartDirective.prototype.ngOnInit = /**\n     * @return {?}\n     */\n        function () {\n            if (this.isBrowser) {\n                this.ctx = this.element.nativeElement.getContext('2d');\n                this.cvs = this.element.nativeElement;\n                this.initFlag = true;\n                if (this.data || this.datasets) {\n                    this.refresh();\n                }\n            }\n        };\n    /**\n     * @param {?} changes\n     * @return {?}\n     */\n    BaseChartDirective.prototype.ngOnChanges = /**\n     * @param {?} changes\n     * @return {?}\n     */\n        function (changes) {\n            if (this.initFlag) {\n                // Check if the changes are in the data or datasets\n                if ((changes.hasOwnProperty('data') || changes.hasOwnProperty('datasets')) &&\n                    !changes.hasOwnProperty('labels')) {\n                    if (changes['data']) {\n                        this.updateChartData(changes['data'].currentValue);\n                    }\n                    else {\n                        this.updateChartData(changes['datasets'].currentValue);\n                    }\n                    this.chart.update();\n                }\n                else {\n                    // otherwise rebuild the chart\n                    this.refresh();\n                }\n            }\n        };\n    /**\n     * @return {?}\n     */\n    BaseChartDirective.prototype.ngOnDestroy = /**\n     * @return {?}\n     */\n        function () {\n            if (this.chart) {\n                this.chart.destroy();\n                this.chart = void 0;\n            }\n        };\n    /**\n     * @param {?} ctx\n     * @return {?}\n     */\n    BaseChartDirective.prototype.getChartBuilder = /**\n     * @param {?} ctx\n     * @return {?}\n     */\n        function (ctx /*, data:Array<any>, options:any*/) {\n            var _this = this;\n            /** @type {?} */\n            var datasets = this.getDatasets();\n            /** @type {?} */\n            var options = Object.assign({}, this.options);\n            if (this.legend === false) {\n                options.legend = { display: false };\n            }\n            // hock for onHover and onClick events\n            options.hover = options.hover || {};\n            if (!options.hover.onHover) {\n                options.hover.onHover = (function (event, active) {\n                    if (active && active.length) {\n                        _this.chartHover.emit({ event: event, active: active });\n                    }\n                });\n            }\n            if (!options.onClick) {\n                options.onClick = (function (event, active) {\n                    _this.chartClick.emit({ event: event, active: active });\n                });\n            }\n            /** @type {?} */\n            var opts = {\n                type: this.chartType,\n                data: {\n                    labels: this.labels,\n                    datasets: datasets,\n                },\n                options: options,\n            };\n            return new Chart(ctx, opts);\n        };\n    // feature(chart): added getPointDataAtEvent which will return clicked chart's point data\n    // feature(chart): added getPointDataAtEvent which will return clicked chart's point data\n    /**\n     * @param {?} event\n     * @return {?}\n     */\n    BaseChartDirective.prototype.getPointDataAtEvent =\n        // feature(chart): added getPointDataAtEvent which will return clicked chart's point data\n        /**\n         * @param {?} event\n         * @return {?}\n         */\n        function (event) {\n            if (event.active.length > 0) {\n                /** @type {?} */\n                var datasetIndex = event.active[0]._datasetIndex;\n                /** @type {?} */\n                var dataIndex = event.active[0]._index;\n                /** @type {?} */\n                var dataObject = this.datasets[datasetIndex].data[dataIndex];\n                return dataObject;\n            }\n        };\n    /**\n     * @private\n     * @param {?} newDataValues\n     * @return {?}\n     */\n    BaseChartDirective.prototype.updateChartData = /**\n     * @private\n     * @param {?} newDataValues\n     * @return {?}\n     */\n        function (newDataValues) {\n            if (Array.isArray(newDataValues[0].data)) {\n                this.chart.data.datasets.forEach((function (dataset, i) {\n                    dataset.data = newDataValues[i].data;\n                    if (newDataValues[i].label) {\n                        dataset.label = newDataValues[i].label;\n                    }\n                }));\n            }\n            else {\n                this.chart.data.datasets[0].data = newDataValues;\n            }\n        };\n    /**\n     * @private\n     * @return {?}\n     */\n    BaseChartDirective.prototype.getDatasets = /**\n     * @private\n     * @return {?}\n     */\n        function () {\n            var _this = this;\n            /** @type {?} */\n            var datasets = void 0;\n            // in case if datasets is not provided, but data is present\n            if (!this.datasets || (!this.datasets.length && (this.data && this.data.length))) {\n                if (Array.isArray(this.data[0])) {\n                    datasets = (((this.data))).map((function (data, index) {\n                        return { data: data, label: _this.labels[index] || \"Label \" + index };\n                    }));\n                }\n                else {\n                    datasets = [{ data: this.data, label: \"Label 0\" }];\n                }\n            }\n            if ((this.datasets && this.datasets.length) || (datasets && datasets.length)) {\n                datasets = (this.datasets || datasets).map((function (elm, index) {\n                    /** @type {?} */\n                    var newElm = Object.assign({}, elm);\n                    if (_this.colors && _this.colors.length) {\n                        Object.assign(newElm, _this.colors[index]);\n                    }\n                    else {\n                        Object.assign(newElm, getColors(_this.chartType, index, newElm.data.length));\n                    }\n                    return newElm;\n                }));\n            }\n            if (!datasets) {\n                throw new Error(\"ng-charts configuration error,\\n      data or datasets field are required to render char \" + this.chartType);\n            }\n            return datasets;\n        };\n    /**\n     * @private\n     * @return {?}\n     */\n    BaseChartDirective.prototype.refresh = /**\n     * @private\n     * @return {?}\n     */\n        function () {\n            this.ngOnDestroy();\n            this.chart = this.getChartBuilder(this.ctx /*, data, this.options*/);\n        };\n    BaseChartDirective.defaultColors = [\n        [255, 99, 132],\n        [54, 162, 235],\n        [255, 206, 86],\n        [231, 233, 237],\n        [75, 192, 192],\n        [151, 187, 205],\n        [220, 220, 220],\n        [247, 70, 74],\n        [70, 191, 189],\n        [253, 180, 92],\n        [148, 159, 177],\n        [77, 83, 96],\n    ];\n    return BaseChartDirective;\n}());\n/**\n * @param {?} colour\n * @param {?} alpha\n * @return {?}\n */\nfunction rgba(colour, alpha) {\n    return 'rgba(' + colour.concat(alpha).join(',') + ')';\n}\n/**\n * @param {?} min\n * @param {?} max\n * @return {?}\n */\nfunction getRandomInt(min, max) {\n    return Math.floor(Math.random() * (max - min + 1)) + min;\n}\n/**\n * @param {?} colors\n * @return {?}\n */\nfunction formatLineColor(colors) {\n    return {\n        backgroundColor: rgba(colors, 0.4),\n        borderColor: rgba(colors, 1),\n        pointBackgroundColor: rgba(colors, 1),\n        pointBorderColor: '#fff',\n        pointHoverBackgroundColor: '#fff',\n        pointHoverBorderColor: rgba(colors, 0.8),\n    };\n}\n/**\n * @param {?} colors\n * @return {?}\n */\nfunction formatBarColor(colors) {\n    return {\n        backgroundColor: rgba(colors, 0.6),\n        borderColor: rgba(colors, 1),\n        hoverBackgroundColor: rgba(colors, 0.8),\n        hoverBorderColor: rgba(colors, 1),\n    };\n}\n/**\n * @param {?} colors\n * @return {?}\n */\nfunction formatPieColors(colors) {\n    return {\n        backgroundColor: colors.map((function (color) { return rgba(color, 0.6); })),\n        borderColor: colors.map((function () { return '#fff'; })),\n        pointBackgroundColor: colors.map((function (color) { return rgba(color, 1); })),\n        pointBorderColor: colors.map((function () { return '#fff'; })),\n        pointHoverBackgroundColor: colors.map((function (color) { return rgba(color, 1); })),\n        pointHoverBorderColor: colors.map((function (color) { return rgba(color, 1); })),\n    };\n}\n/**\n * @param {?} colors\n * @return {?}\n */\nfunction formatPolarAreaColors(colors) {\n    return {\n        backgroundColor: colors.map((function (color) { return rgba(color, 0.6); })),\n        borderColor: colors.map((function (color) { return rgba(color, 1); })),\n        hoverBackgroundColor: colors.map((function (color) { return rgba(color, 0.8); })),\n        hoverBorderColor: colors.map((function (color) { return rgba(color, 1); })),\n    };\n}\n/**\n * @return {?}\n */\nfunction getRandomColor() {\n    return [getRandomInt(0, 255), getRandomInt(0, 255), getRandomInt(0, 255)];\n}\n/**\n * Generate colors for line|bar charts\n * @param {?} index\n * @return {?}\n */\nfunction generateColor(index) {\n    return BaseChartDirective.defaultColors[index] || getRandomColor();\n}\n/**\n * Generate colors for pie|doughnut charts\n * @param {?} count\n * @return {?}\n */\nfunction generateColors(count) {\n    /** @type {?} */\n    var colorsArr = new Array(count);\n    for (var i = 0; i < count; i++) {\n        colorsArr[i] = BaseChartDirective.defaultColors[i] || getRandomColor();\n    }\n    return colorsArr;\n}\n/**\n * Generate colors by chart type\n * @param {?} chartType\n * @param {?} index\n * @param {?} count\n * @return {?}\n */\nfunction getColors(chartType, index, count) {\n    if (chartType === 'pie' || chartType === 'doughnut') {\n        return formatPieColors(generateColors(count));\n    }\n    if (chartType === 'polarArea') {\n        return formatPolarAreaColors(generateColors(count));\n    }\n    if (chartType === 'line' || chartType === 'radar') {\n        return formatLineColor(generateColor(index));\n    }\n    if (chartType === 'bar' || chartType === 'horizontalBar') {\n        return formatBarColor(generateColor(index));\n    }\n    return generateColor(index);\n}\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\nvar ChartsModule = /*@__PURE__*/ (function () {\n    function ChartsModule() {\n    }\n    return ChartsModule;\n}());\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/** @type {?} */\nvar CHECKBOX_VALUE_ACCESSOR = {\n    provide: NG_VALUE_ACCESSOR,\n    // tslint:disable-next-line: no-use-before-declare\n    useExisting: forwardRef((function () { return CheckboxComponent; })),\n    multi: true,\n};\n/** @type {?} */\nvar defaultIdNumber = 0;\nvar MdbCheckboxChange = /*@__PURE__*/ (function () {\n    function MdbCheckboxChange() {\n    }\n    return MdbCheckboxChange;\n}());\nvar CheckboxComponent = /*@__PURE__*/ (function () {\n    function CheckboxComponent() {\n        this.defaultId = \"mdb-checkbox-\" + ++defaultIdNumber;\n        this.id = this.defaultId;\n        this.checked = false;\n        this.filledIn = false;\n        this.indeterminate = false;\n        this.rounded = false;\n        this.checkboxPosition = 'left';\n        this.default = false;\n        this.inline = false;\n        this.change = new EventEmitter();\n        this.checkboxClicked = new Subject();\n        // Control Value Accessor Methods\n        this.onChange = (function (_) { });\n        this.onTouched = (function () { });\n    }\n    /**\n     * @param {?} event\n     * @return {?}\n     */\n    CheckboxComponent.prototype.onLabelClick = /**\n     * @param {?} event\n     * @return {?}\n     */\n        function (event) {\n            event.stopPropagation();\n            this.checkboxClicked.next(true);\n        };\n    /**\n     * @return {?}\n     */\n    CheckboxComponent.prototype.onDocumentClick = /**\n     * @return {?}\n     */\n        function () {\n            this.checkboxClicked.next(false);\n        };\n    /**\n     * @return {?}\n     */\n    CheckboxComponent.prototype.ngOnInit = /**\n     * @return {?}\n     */\n        function () {\n            if (this.indeterminate && !this.filledIn && !this.rounded) {\n                this.inputEl.indeterminate = true;\n            }\n        };\n    /**\n     * @param {?} changes\n     * @return {?}\n     */\n    CheckboxComponent.prototype.ngOnChanges = /**\n     * @param {?} changes\n     * @return {?}\n     */\n        function (changes) {\n            if (changes.hasOwnProperty('checked')) {\n                this.checked = changes.checked.currentValue;\n            }\n        };\n    Object.defineProperty(CheckboxComponent.prototype, \"changeEvent\", {\n        get: /**\n         * @return {?}\n         */ function () {\n            /** @type {?} */\n            var newChangeEvent = new MdbCheckboxChange();\n            newChangeEvent.element = this;\n            newChangeEvent.checked = this.checked;\n            return newChangeEvent;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * @return {?}\n     */\n    CheckboxComponent.prototype.toggle = /**\n     * @return {?}\n     */\n        function () {\n            if (this.disabled) {\n                return;\n            }\n            this.checked = !this.checked;\n            this.indeterminate = false;\n            this.onChange(this.checked);\n        };\n    /**\n     * @param {?} event\n     * @return {?}\n     */\n    CheckboxComponent.prototype.onCheckboxClick = /**\n     * @param {?} event\n     * @return {?}\n     */\n        function (event) {\n            event.stopPropagation();\n            this.toggle();\n        };\n    /**\n     * @param {?} event\n     * @return {?}\n     */\n    CheckboxComponent.prototype.onCheckboxChange = /**\n     * @param {?} event\n     * @return {?}\n     */\n        function (event) {\n            var _this = this;\n            event.stopPropagation();\n            timer(0).subscribe((function () { return _this.change.emit(_this.changeEvent); }));\n        };\n    /**\n     * @return {?}\n     */\n    CheckboxComponent.prototype.onBlur = /**\n     * @return {?}\n     */\n        function () {\n            var _this = this;\n            this.checkboxClicked.pipe(take(1)).subscribe((function (val) {\n                if (!val) {\n                    _this.onTouched();\n                }\n            }));\n        };\n    /**\n     * @param {?} value\n     * @return {?}\n     */\n    CheckboxComponent.prototype.writeValue = /**\n     * @param {?} value\n     * @return {?}\n     */\n        function (value) {\n            this.value = value;\n            this.checked = !!value;\n        };\n    /**\n     * @param {?} fn\n     * @return {?}\n     */\n    CheckboxComponent.prototype.registerOnChange = /**\n     * @param {?} fn\n     * @return {?}\n     */\n        function (fn) {\n            this.onChange = fn;\n        };\n    /**\n     * @param {?} fn\n     * @return {?}\n     */\n    CheckboxComponent.prototype.registerOnTouched = /**\n     * @param {?} fn\n     * @return {?}\n     */\n        function (fn) {\n            this.onTouched = fn;\n        };\n    /**\n     * @param {?} isDisabled\n     * @return {?}\n     */\n    CheckboxComponent.prototype.setDisabledState = /**\n     * @param {?} isDisabled\n     * @return {?}\n     */\n        function (isDisabled) {\n            this.disabled = isDisabled;\n        };\n    return CheckboxComponent;\n}());\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\nvar CheckboxModule = /*@__PURE__*/ (function () {\n    function CheckboxModule() {\n    }\n    return CheckboxModule;\n}());\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\nvar CollapseComponent = /*@__PURE__*/ (function () {\n    function CollapseComponent() {\n        this.isCollapsed = true;\n        this.showBsCollapse = new EventEmitter();\n        this.shownBsCollapse = new EventEmitter();\n        this.hideBsCollapse = new EventEmitter();\n        this.hiddenBsCollapse = new EventEmitter();\n        this.collapsed = new EventEmitter();\n        this.expanded = new EventEmitter();\n        this.overflow = 'hidden';\n    }\n    /**\n     * @param {?} event\n     * @return {?}\n     */\n    CollapseComponent.prototype.onExpandBodyDone = /**\n     * @param {?} event\n     * @return {?}\n     */\n        function (event) {\n            var _this = this;\n            setTimeout((function () {\n                if (event.toState === 'expanded') {\n                    _this.shownBsCollapse.emit(_this);\n                    _this.expanded.emit(_this);\n                    _this.overflow = 'visible';\n                    _this.showCaptions();\n                }\n                else {\n                    _this.hiddenBsCollapse.emit(_this);\n                    _this.collapsed.emit(_this);\n                }\n            }), 0);\n        };\n    /**\n     * @return {?}\n     */\n    CollapseComponent.prototype.showCaptions = /**\n     * @return {?}\n     */\n        function () {\n            this.captions.forEach((function (caption) { return caption.showCaption(); }));\n        };\n    /**\n     * @return {?}\n     */\n    CollapseComponent.prototype.toggle = /**\n     * @return {?}\n     */\n        function () {\n            this.isCollapsed ? this.show() : this.hide();\n        };\n    /**\n     * @return {?}\n     */\n    CollapseComponent.prototype.show = /**\n     * @return {?}\n     */\n        function () {\n            this.expandAnimationState = 'expanded';\n            this.isCollapsed = false;\n            this.showBsCollapse.emit(this);\n        };\n    /**\n     * @return {?}\n     */\n    CollapseComponent.prototype.hide = /**\n     * @return {?}\n     */\n        function () {\n            this.overflow = 'hidden';\n            this.expandAnimationState = 'collapsed';\n            this.isCollapsed = true;\n            this.hideBsCollapse.emit(this);\n        };\n    /**\n     * @return {?}\n     */\n    CollapseComponent.prototype.initializeCollapseState = /**\n     * @return {?}\n     */\n        function () {\n            this.isCollapsed ? this.hide() : this.show();\n        };\n    /**\n     * @return {?}\n     */\n    CollapseComponent.prototype.ngOnInit = /**\n     * @return {?}\n     */\n        function () {\n            this.initializeCollapseState();\n        };\n    return CollapseComponent;\n}());\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\nvar CollapseModule = /*@__PURE__*/ (function () {\n    function CollapseModule() {\n    }\n    /**\n     * @return {?}\n     */\n    CollapseModule.forRoot = /**\n     * @return {?}\n     */\n        function () {\n            return { ngModule: CollapseModule, providers: [] };\n        };\n    return CollapseModule;\n}());\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * @copyright Valor Software\n * @copyright Angular ng-bootstrap team\n */\nvar Trigger = /*@__PURE__*/ (function () {\n    function Trigger(open, close) {\n        this.open = open;\n        this.close = close || open;\n    }\n    /**\n     * @return {?}\n     */\n    Trigger.prototype.isManual = /**\n     * @return {?}\n     */\n        function () {\n            return this.open === 'manual' || this.close === 'manual';\n        };\n    return Trigger;\n}());\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/** @type {?} */\nvar DEFAULT_ALIASES = {\n    hover: ['mouseover', 'mouseout'],\n    focus: ['focusin', 'focusout']\n};\n/* tslint:disable-next-line: no-any */\n/**\n * @param {?} triggers\n * @param {?=} aliases\n * @return {?}\n */\nfunction parseTriggers(triggers, aliases) {\n    if (aliases === void 0) {\n        aliases = DEFAULT_ALIASES;\n    }\n    /** @type {?} */\n    var trimmedTriggers = (triggers || '').trim();\n    if (trimmedTriggers.length === 0) {\n        return [];\n    }\n    /** @type {?} */\n    var parsedTriggers = trimmedTriggers\n        .split(/\\s+/)\n        .map((function (trigger$$1) { return trigger$$1.split(':'); }))\n        .map((function (triggerPair) {\n        /** @type {?} */\n        var alias = aliases[triggerPair[0]] || triggerPair;\n        return new Trigger(alias[0], alias[1]);\n    }));\n    /** @type {?} */\n    var manualTriggers = parsedTriggers.filter((function (triggerPair) {\n        return triggerPair.isManual();\n    }));\n    if (manualTriggers.length > 1) {\n        throw new Error('Triggers parse error: only one manual trigger is allowed');\n    }\n    if (manualTriggers.length === 1 && parsedTriggers.length > 1) {\n        throw new Error('Triggers parse error: manual trigger can\\'t be mixed with other triggers');\n    }\n    return parsedTriggers;\n}\n/**\n * @param {?} renderer\n * @param {?} options\n * @return {?}\n */\nfunction listenToTriggersV2(renderer, options) {\n    /** @type {?} */\n    var parsedTriggers = parseTriggers(options.triggers);\n    /** @type {?} */\n    var target = options.target;\n    // do nothing\n    if (parsedTriggers.length === 1 && parsedTriggers[0].isManual()) {\n        return Function.prototype;\n    }\n    // all listeners\n    /* tslint:disable-next-line: no-any */\n    /** @type {?} */\n    var listeners = [];\n    // lazy listeners registration\n    /** @type {?} */\n    var _registerHide = [];\n    /** @type {?} */\n    var registerHide = (function () {\n        // add hide listeners to unregister array\n        _registerHide.forEach((function (fn) { return listeners.push(fn()); }));\n        // register hide events only once\n        _registerHide.length = 0;\n    });\n    // register open\\close\\toggle listeners\n    parsedTriggers.forEach((function (trigger$$1) {\n        /** @type {?} */\n        var useToggle = trigger$$1.open === trigger$$1.close;\n        /** @type {?} */\n        var showFn = useToggle ? options.toggle : options.show;\n        if (!useToggle) {\n            _registerHide.push((function () {\n                return renderer.listen(target, trigger$$1.close, options.hide);\n            }));\n        }\n        listeners.push(renderer.listen(target, trigger$$1.open, (function () { return showFn(registerHide); })));\n    }));\n    return (function () {\n        listeners.forEach((function (unsubscribeFn) { return unsubscribeFn(); }));\n    });\n}\n/**\n * @param {?} renderer\n * @param {?} options\n * @return {?}\n */\nfunction registerOutsideClick(renderer, options) {\n    if (!options.outsideClick) {\n        return Function.prototype;\n    }\n    /* tslint:disable-next-line: no-any */\n    return renderer.listen('document', 'click', (function (event) {\n        if (options.target && options.target.contains(event.target)) {\n            return undefined;\n        }\n        if (options.targets &&\n            options.targets.some((function (target) { return target.contains(event.target); }))) {\n            return undefined;\n        }\n        options.hide();\n    }));\n}\n/**\n * @param {?} renderer\n * @param {?} options\n * @return {?}\n */\nfunction registerEscClick(renderer, options) {\n    if (!options.outsideEsc) {\n        return Function.prototype;\n    }\n    return renderer.listen('document', 'keyup.esc', (function (event) {\n        if (options.target && options.target.contains(event.target)) {\n            return undefined;\n        }\n        if (options.targets &&\n            options.targets.some((function (target) { return target.contains(event.target); }))) {\n            return undefined;\n        }\n        options.hide();\n    }));\n}\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * JS version of browser APIs. This library can only run in the browser.\n * @type {?}\n */\nvar win$1 = (typeof window !== 'undefined' && window) || (({}));\n/** @type {?} */\nvar document$2 = win$1.document;\n/** @type {?} */\nvar location$1 = win$1.location;\n/** @type {?} */\nvar gc$1 = win$1.gc ? (function () { return win$1.gc(); }) : (function () { return null; });\n/** @type {?} */\nvar performance$1 = win$1.performance ? win$1.performance : null;\n/** @type {?} */\nvar Event$1 = win$1.Event;\n/** @type {?} */\nvar MouseEvent$1 = win$1.MouseEvent;\n/** @type {?} */\nvar KeyboardEvent$1 = win$1.KeyboardEvent;\n/** @type {?} */\nvar EventTarget$1 = win$1.EventTarget;\n/** @type {?} */\nvar History$1 = win$1.History;\n/** @type {?} */\nvar Location$1 = win$1.Location;\n/** @type {?} */\nvar EventListener$1 = win$1.EventListener;\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * @copyright Valor Software\n * @copyright Angular ng-bootstrap team\n */\nvar ContentRef = /*@__PURE__*/ (function () {\n    function ContentRef(\n        /* tslint:disable-next-line: no-any */\n        nodes, viewRef, \n        /* tslint:disable-next-line: no-any */\n        componentRef) {\n        this.nodes = nodes;\n        this.viewRef = viewRef;\n        this.componentRef = componentRef;\n    }\n    return ContentRef;\n}());\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * @template T\n */\nvar /**\n * @template T\n */ ComponentLoader = /*@__PURE__*/ (function () {\n    /**\n     * Do not use this directly, it should be instanced via\n     * `ComponentLoadFactory.attach`\n     * @internal\n     */\n    // tslint:disable-next-line\n    function ComponentLoader(_viewContainerRef, _renderer, _elementRef, _injector, _componentFactoryResolver, _ngZone, _applicationRef, _posService) {\n        this._viewContainerRef = _viewContainerRef;\n        this._renderer = _renderer;\n        this._elementRef = _elementRef;\n        this._injector = _injector;\n        this._componentFactoryResolver = _componentFactoryResolver;\n        this._ngZone = _ngZone;\n        this._applicationRef = _applicationRef;\n        this._posService = _posService;\n        this.onBeforeShow = new EventEmitter();\n        /* tslint:disable-next-line: no-any*/\n        this.onShown = new EventEmitter();\n        /* tslint:disable-next-line: no-any*/\n        this.onBeforeHide = new EventEmitter();\n        this.onHidden = new EventEmitter();\n        this.shown = new EventEmitter();\n        this.hidden = new EventEmitter();\n        this._providers = [];\n        this._isHiding = false;\n        /**\n         * A selector used if container element was not found\n         */\n        this.containerDefaultSelector = 'body';\n        this._listenOpts = {};\n        this._globalListener = Function.prototype;\n    }\n    Object.defineProperty(ComponentLoader.prototype, \"isShown\", {\n        get: /**\n         * @return {?}\n         */ function () {\n            if (this._isHiding) {\n                return false;\n            }\n            return !!this._componentRef;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * @param {?} compType\n     * @return {?}\n     */\n    ComponentLoader.prototype.attach = /**\n     * @param {?} compType\n     * @return {?}\n     */\n        function (compType) {\n            this._componentFactory = this._componentFactoryResolver\n                .resolveComponentFactory(compType);\n            return this;\n        };\n    // todo: add behaviour: to target element, `body`, custom element\n    // todo: add behaviour: to target element, `body`, custom element\n    /**\n     * @param {?=} container\n     * @return {?}\n     */\n    ComponentLoader.prototype.to =\n        // todo: add behaviour: to target element, `body`, custom element\n        /**\n         * @param {?=} container\n         * @return {?}\n         */\n        function (container) {\n            this.container = container || this.container;\n            return this;\n        };\n    /**\n     * @param {?=} opts\n     * @return {?}\n     */\n    ComponentLoader.prototype.position = /**\n     * @param {?=} opts\n     * @return {?}\n     */\n        function (opts) {\n            this.attachment = opts.attachment || this.attachment;\n            this._elementRef = (((opts.target))) || this._elementRef;\n            return this;\n        };\n    /**\n     * @param {?} provider\n     * @return {?}\n     */\n    ComponentLoader.prototype.provide = /**\n     * @param {?} provider\n     * @return {?}\n     */\n        function (provider) {\n            this._providers.push(provider);\n            return this;\n        };\n    // todo: appendChild to element or document.querySelector(this.container)\n    // todo: appendChild to element or document.querySelector(this.container)\n    /**\n     * @param {?=} opts\n     * @return {?}\n     */\n    ComponentLoader.prototype.show =\n        // todo: appendChild to element or document.querySelector(this.container)\n        /**\n         * @param {?=} opts\n         * @return {?}\n         */\n        function (opts) {\n            if (opts === void 0) {\n                opts = {};\n            }\n            this._subscribePositioning();\n            this._innerComponent = null;\n            if (!this._componentRef) {\n                this.onBeforeShow.emit();\n                this._contentRef = this._getContentRef(opts.content, opts.data);\n                /** @type {?} */\n                var injector = Injector.create({\n                    providers: this._providers,\n                    parent: this._injector\n                });\n                this._componentRef = this._componentFactory.create(injector, this._contentRef.nodes);\n                this._applicationRef.attachView(this._componentRef.hostView);\n                // this._componentRef = this._viewContainerRef\n                //   .createComponent(this._componentFactory, 0, injector, this._contentRef.nodes);\n                this.instance = this._componentRef.instance;\n                Object.assign(this._componentRef.instance, opts);\n                if (this.container instanceof ElementRef) {\n                    this.container.nativeElement.appendChild(this._componentRef.location.nativeElement);\n                }\n                if (typeof this.container === 'string' && typeof document !== 'undefined') {\n                    /** @type {?} */\n                    var selectedElement = document.querySelector(this.container) ||\n                        document.querySelector(this.containerDefaultSelector);\n                    if (selectedElement) {\n                        selectedElement.appendChild(this._componentRef.location.nativeElement);\n                    }\n                }\n                if (!this.container &&\n                    this._elementRef &&\n                    this._elementRef.nativeElement.parentElement) {\n                    this._elementRef.nativeElement.parentElement.appendChild(this._componentRef.location.nativeElement);\n                }\n                // we need to manually invoke change detection since events registered\n                // via\n                // Renderer::listen() are not picked up by change detection with the\n                // OnPush strategy\n                if (this._contentRef.componentRef) {\n                    this._innerComponent = this._contentRef.componentRef.instance;\n                    this._contentRef.componentRef.changeDetectorRef.markForCheck();\n                    this._contentRef.componentRef.changeDetectorRef.detectChanges();\n                }\n                this._componentRef.changeDetectorRef.markForCheck();\n                this._componentRef.changeDetectorRef.detectChanges();\n                this.onShown.emit(this._componentRef.instance);\n            }\n            this._registerOutsideClick();\n            return this._componentRef;\n        };\n    /**\n     * @return {?}\n     */\n    ComponentLoader.prototype.hide = /**\n     * @return {?}\n     */\n        function () {\n            if (!this._componentRef) {\n                return this;\n            }\n            this._posService.deletePositionElement(this._componentRef.location);\n            this.onBeforeHide.emit(this._componentRef.instance);\n            /** @type {?} */\n            var componentEl = this._componentRef.location.nativeElement;\n            componentEl.parentNode.removeChild(componentEl);\n            if (this._contentRef.componentRef) {\n                this._contentRef.componentRef.destroy();\n            }\n            this._componentRef.destroy();\n            if (this._viewContainerRef && this._contentRef.viewRef) {\n                this._viewContainerRef.remove(this._viewContainerRef.indexOf(this._contentRef.viewRef));\n            }\n            if (this._contentRef.viewRef) {\n                this._contentRef.viewRef.destroy();\n            }\n            this._contentRef = null;\n            this._componentRef = null;\n            this._removeGlobalListener();\n            this.onHidden.emit();\n            return this;\n        };\n    /**\n     * @return {?}\n     */\n    ComponentLoader.prototype.toggle = /**\n     * @return {?}\n     */\n        function () {\n            if (this.isShown) {\n                this.hide();\n                return;\n            }\n            this.show();\n        };\n    /**\n     * @return {?}\n     */\n    ComponentLoader.prototype.dispose = /**\n     * @return {?}\n     */\n        function () {\n            if (this.isShown) {\n                this.hide();\n            }\n            this._unsubscribePositioning();\n            if (this._unregisterListenersFn) {\n                this._unregisterListenersFn();\n            }\n        };\n    /**\n     * @param {?} listenOpts\n     * @return {?}\n     */\n    ComponentLoader.prototype.listen = /**\n     * @param {?} listenOpts\n     * @return {?}\n     */\n        function (listenOpts) {\n            var _this = this;\n            this.triggers = listenOpts.triggers || this.triggers;\n            this._listenOpts.outsideClick = listenOpts.outsideClick;\n            this._listenOpts.outsideEsc = listenOpts.outsideEsc;\n            listenOpts.target = listenOpts.target || this._elementRef.nativeElement;\n            /** @type {?} */\n            var hide = (this._listenOpts.hide = (function () {\n                return listenOpts.hide ? listenOpts.hide() : void _this.hide();\n            }));\n            /** @type {?} */\n            var show = (this._listenOpts.show = (function (registerHide) {\n                listenOpts.show ? listenOpts.show(registerHide) : _this.show(registerHide);\n                registerHide();\n            }));\n            /** @type {?} */\n            var toggle = (function (registerHide) {\n                _this.isShown ? hide() : show(registerHide);\n            });\n            this._unregisterListenersFn = listenToTriggersV2(this._renderer, {\n                target: listenOpts.target,\n                triggers: listenOpts.triggers,\n                show: show,\n                hide: hide,\n                toggle: toggle\n            });\n            return this;\n        };\n    /**\n     * @return {?}\n     */\n    ComponentLoader.prototype._removeGlobalListener = /**\n     * @return {?}\n     */\n        function () {\n            if (this._globalListener) {\n                this._globalListener();\n                this._globalListener = null;\n            }\n        };\n    /**\n     * @param {?} vRef\n     * @param {?} template\n     * @return {?}\n     */\n    ComponentLoader.prototype.attachInline = /**\n     * @param {?} vRef\n     * @param {?} template\n     * @return {?}\n     */\n        function (vRef, \n            /* tslint:disable-next-line: no-any*/\n            template) {\n            this._inlineViewRef = vRef.createEmbeddedView(template);\n            return this;\n        };\n    /**\n     * @return {?}\n     */\n    ComponentLoader.prototype._registerOutsideClick = /**\n     * @return {?}\n     */\n        function () {\n            var _this = this;\n            if (!this._componentRef || !this._componentRef.location) {\n                return;\n            }\n            // why: should run after first event bubble\n            if (this._listenOpts && this._listenOpts.outsideClick) {\n                /** @type {?} */\n                var target_1 = this._componentRef.location.nativeElement;\n                setTimeout((function () {\n                    _this._globalListener = registerOutsideClick(_this._renderer, {\n                        targets: [target_1, _this._elementRef.nativeElement],\n                        outsideClick: _this._listenOpts.outsideClick,\n                        hide: (function () { return _this._listenOpts.hide(); })\n                    });\n                }));\n            }\n            if (this._listenOpts.outsideEsc) {\n                /** @type {?} */\n                var target = this._componentRef.location.nativeElement;\n                this._globalListener = registerEscClick(this._renderer, {\n                    targets: [target, this._elementRef.nativeElement],\n                    outsideEsc: this._listenOpts.outsideEsc,\n                    hide: (function () { return _this._listenOpts.hide(); })\n                });\n            }\n        };\n    /**\n     * @return {?}\n     */\n    ComponentLoader.prototype.getInnerComponent = /**\n     * @return {?}\n     */\n        function () {\n            return this._innerComponent;\n        };\n    /**\n     * @private\n     * @return {?}\n     */\n    ComponentLoader.prototype._subscribePositioning = /**\n     * @private\n     * @return {?}\n     */\n        function () {\n            var _this = this;\n            if (this._zoneSubscription || !this.attachment) {\n                return;\n            }\n            this.onShown.subscribe((function () {\n                _this._posService.position({\n                    element: _this._componentRef.location,\n                    target: _this._elementRef,\n                    attachment: _this.attachment,\n                    appendToBody: _this.container === 'body'\n                });\n            }));\n            this._zoneSubscription = this._ngZone.onStable.subscribe((function () {\n                if (!_this._componentRef) {\n                    return;\n                }\n                _this._posService.calcPosition();\n            }));\n        };\n    /**\n     * @private\n     * @return {?}\n     */\n    ComponentLoader.prototype._unsubscribePositioning = /**\n     * @private\n     * @return {?}\n     */\n        function () {\n            if (!this._zoneSubscription) {\n                return;\n            }\n            this._zoneSubscription.unsubscribe();\n            this._zoneSubscription = null;\n        };\n    /**\n     * @private\n     * @param {?} content\n     * @param {?=} data\n     * @return {?}\n     */\n    ComponentLoader.prototype._getContentRef = /**\n     * @private\n     * @param {?} content\n     * @param {?=} data\n     * @return {?}\n     */\n        function (\n            /* tslint:disable-next-line: no-any*/\n            content, \n            /* tslint:disable-next-line: no-any*/\n            data) {\n            if (!content) {\n                return new ContentRef([]);\n            }\n            if (content instanceof TemplateRef) {\n                if (this._viewContainerRef) {\n                    /** @type {?} */\n                    var _viewRef = this._viewContainerRef\n                        .createEmbeddedView(content);\n                    _viewRef.markForCheck();\n                    return new ContentRef([_viewRef.rootNodes], _viewRef);\n                }\n                /** @type {?} */\n                var viewRef = content.createEmbeddedView({});\n                this._applicationRef.attachView(viewRef);\n                return new ContentRef([viewRef.rootNodes], viewRef);\n            }\n            if (typeof content === 'function') {\n                /** @type {?} */\n                var contentCmptFactory = this._componentFactoryResolver.resolveComponentFactory(content);\n                /** @type {?} */\n                var modalContentInjector = Injector.create({\n                    providers: this._providers,\n                    parent: this._injector\n                });\n                /** @type {?} */\n                var componentRef = contentCmptFactory.create(modalContentInjector);\n                Object.assign(componentRef.instance, data);\n                this._applicationRef.attachView(componentRef.hostView);\n                return new ContentRef([[componentRef.location.nativeElement]], componentRef.hostView, componentRef);\n            }\n            return new ContentRef([[this._renderer.createText(\"\" + content)]]);\n        };\n    return ComponentLoader;\n}());\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * Get CSS computed property of the given element\n * @param {?} element\n * @param {?=} property\n * @return {?}\n */\nfunction getStyleComputedProperty(element, property) {\n    if (element.nodeType !== 1) {\n        return [];\n    }\n    // NOTE: 1 DOM access here\n    /** @type {?} */\n    var window = element.ownerDocument.defaultView;\n    /** @type {?} */\n    var css = window.getComputedStyle(element, null);\n    return property ? css[((property))] : css;\n}\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * Returns the parentNode or the host of the element\n * @param {?} element\n * @return {?}\n */\nfunction getParentNode(element) {\n    if (element.nodeName === 'HTML') {\n        return element;\n    }\n    return element.parentNode || element.host;\n}\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * @param {?} element\n * @return {?}\n */\nfunction getScrollParent(element) {\n    // Return body, `getScroll` will take care to get the correct `scrollTop` from it\n    if (!element) {\n        return document.body;\n    }\n    switch (element.nodeName) {\n        case 'HTML':\n        case 'BODY':\n            return element.ownerDocument.body;\n        case '#document':\n            return element.body;\n        default:\n    }\n    // Firefox want us to check `-x` and `-y` variations as well\n    var _a = getStyleComputedProperty(element), overflow = _a.overflow, overflowX = _a.overflowX, overflowY = _a.overflowY;\n    if (/(auto|scroll|overlay)/.test(String(overflow) + String(overflowY) + String(overflowX))) {\n        return element;\n    }\n    return getScrollParent(getParentNode(element));\n}\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/** @type {?} */\nvar isBrowser = typeof window !== 'undefined' && typeof document !== 'undefined';\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/** @type {?} */\nvar isIE11 = isBrowser && !!((((window))).MSInputMethodContext && (((document))).documentMode);\n/** @type {?} */\nvar isIE10 = isBrowser && !!((((window))).MSInputMethodContext && /MSIE 10/.test((((navigator))).userAgent));\n/**\n * @param {?=} version\n * @return {?}\n */\nfunction isIE(version) {\n    if (version === 11) {\n        return isIE11;\n    }\n    if (version === 10) {\n        return isIE10;\n    }\n    return isIE11 || isIE10;\n}\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * @param {?} element\n * @return {?}\n */\nfunction getOffsetParent(element) {\n    if (!element) {\n        return document.documentElement;\n    }\n    /** @type {?} */\n    var noOffsetParent = isIE(10) ? document.body : null;\n    // NOTE: 1 DOM access here\n    /** @type {?} */\n    var offsetParent = element.offsetParent || null;\n    // Skip hidden elements which don't have an offsetParent\n    /** @type {?} */\n    var sibling;\n    while (offsetParent === noOffsetParent && element.nextElementSibling && element.nodeName !== 'BODY') {\n        sibling = element.nextElementSibling;\n        offsetParent = sibling.offsetParent;\n    }\n    /** @type {?} */\n    var nodeName = offsetParent && offsetParent.nodeName;\n    if (!nodeName || nodeName === 'BODY' || nodeName === 'HTML') {\n        return sibling ? sibling.ownerDocument.documentElement : document.documentElement;\n    }\n    // .offsetParent will return the closest TH, TD or TABLE in case\n    // no offsetParent is present, I hate this job...\n    if (['TH', 'TD', 'TABLE'].indexOf(offsetParent.nodeName) !== -1 &&\n        getStyleComputedProperty(offsetParent, 'position') === 'static') {\n        return getOffsetParent(offsetParent);\n    }\n    return offsetParent;\n}\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * @param {?} element\n * @return {?}\n */\nfunction isOffsetContainer(element) {\n    var nodeName = element.nodeName;\n    if (nodeName === 'BODY') {\n        return false;\n    }\n    return (nodeName === 'HTML' || getOffsetParent(element.firstElementChild) === element);\n}\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * Finds the root node (document, shadowDOM root) of the given element\n * @param {?} node\n * @return {?}\n */\nfunction getRoot(node) {\n    if (node.parentNode !== null) {\n        return getRoot(node.parentNode);\n    }\n    return node;\n}\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * @param {?} element1\n * @param {?} element2\n * @return {?}\n */\nfunction findCommonOffsetParent(element1, element2) {\n    // This check is needed to avoid errors in case one of the elements isn't defined for any reason\n    if (!element1 || !element1.nodeType || !element2 || !element2.nodeType) {\n        return document.documentElement;\n    }\n    // Here we make sure to give as \"start\" the element that comes first in the DOM\n    /* tslint:disable-next-line: no-bitwise */\n    /** @type {?} */\n    var order = element1.compareDocumentPosition(element2) & Node.DOCUMENT_POSITION_FOLLOWING;\n    /** @type {?} */\n    var start = order ? element1 : element2;\n    /** @type {?} */\n    var end = order ? element2 : element1;\n    // Get common ancestor container\n    /** @type {?} */\n    var range = document.createRange();\n    range.setStart(start, 0);\n    range.setEnd(end, 0);\n    var commonAncestorContainer = range.commonAncestorContainer;\n    // Both nodes are inside #document\n    if ((element1 !== commonAncestorContainer &&\n        element2 !== commonAncestorContainer) ||\n        start.contains(end)) {\n        if (isOffsetContainer(commonAncestorContainer)) {\n            return commonAncestorContainer;\n        }\n        return getOffsetParent(commonAncestorContainer);\n    }\n    // one of the nodes is inside shadowDOM, find which one\n    /** @type {?} */\n    var element1root = getRoot(element1);\n    if (element1root.host) {\n        return findCommonOffsetParent(element1root.host, element2);\n    }\n    else {\n        return findCommonOffsetParent(element1, getRoot(element2).host);\n    }\n}\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * Helper to detect borders of a given element\n */\n/**\n * @param {?} styles\n * @param {?} axis\n * @return {?}\n */\nfunction getBordersSize(styles, axis) {\n    /** @type {?} */\n    var sideA = axis === 'x' ? 'Left' : 'Top';\n    /** @type {?} */\n    var sideB = sideA === 'Left' ? 'Right' : 'Bottom';\n    return (parseFloat(styles[((\"border\" + sideA + \"Width\"))]) +\n        parseFloat(styles[((\"border\" + sideB + \"Width\"))]));\n}\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * @param {?} axis\n * @param {?} body\n * @param {?} html\n * @param {?} computedStyle\n * @return {?}\n */\nfunction getSize(axis, body, html, computedStyle) {\n    return Math.max((((body)))[\"offset\" + axis], (((body)))[\"scroll\" + axis], (((html)))[\"client\" + axis], (((html)))[\"offset\" + axis], (((html)))[\"scroll\" + axis], isIE(10)\n        ? (parseInt((((html)))[\"offset\" + axis], 10) +\n            parseInt(computedStyle[((\"margin\" + (axis === 'Height' ? 'Top' : 'Left')))], 10) +\n            parseInt(computedStyle[((\"margin\" + (axis === 'Height' ? 'Bottom' : 'Right')))], 10))\n        : 0);\n}\n/**\n * @param {?} document\n * @return {?}\n */\nfunction getWindowSizes(document) {\n    /** @type {?} */\n    var body = document.body;\n    /** @type {?} */\n    var html = document.documentElement;\n    /** @type {?} */\n    var computedStyle = isIE(10) && getComputedStyle(html);\n    return {\n        height: getSize('Height', body, html, computedStyle),\n        width: getSize('Width', body, html, computedStyle)\n    };\n}\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * Gets the scroll value of the given element in the given side (top and left)\n * @param {?} element\n * @param {?=} side\n * @return {?}\n */\nfunction getScroll(element, side) {\n    if (side === void 0) {\n        side = 'top';\n    }\n    /** @type {?} */\n    var upperSide = side === 'top' ? 'scrollTop' : 'scrollLeft';\n    /** @type {?} */\n    var nodeName = element.nodeName;\n    if (nodeName === 'BODY' || nodeName === 'HTML') {\n        /** @type {?} */\n        var html = element.ownerDocument.documentElement;\n        /** @type {?} */\n        var scrollingElement = element.ownerDocument.scrollingElement || html;\n        return scrollingElement[upperSide];\n    }\n    return element[upperSide];\n}\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * @param {?} offsets\n * @return {?}\n */\nfunction getClientRect(offsets) {\n    return __assign({}, offsets, { right: offsets.left + offsets.width, bottom: offsets.top + offsets.height });\n}\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * @param {?} element\n * @return {?}\n */\nfunction getBoundingClientRect(element) {\n    /** @type {?} */\n    var rect = {};\n    // IE10 10 FIX: Please, don't ask, the element isn't\n    // considered in DOM in some circumstances...\n    // This isn't reproducible in IE10 compatibility mode of IE11\n    try {\n        if (isIE(10)) {\n            rect = element.getBoundingClientRect();\n            /** @type {?} */\n            var scrollTop = getScroll(element, 'top');\n            /** @type {?} */\n            var scrollLeft = getScroll(element, 'left');\n            rect.top += scrollTop;\n            rect.left += scrollLeft;\n            rect.bottom += scrollTop;\n            rect.right += scrollLeft;\n        }\n        else {\n            rect = element.getBoundingClientRect();\n        }\n    }\n    catch (e) {\n        return undefined;\n    }\n    /** @type {?} */\n    var result = {\n        left: rect.left,\n        top: rect.top,\n        width: rect.right - rect.left,\n        height: rect.bottom - rect.top\n    };\n    // subtract scrollbar size from sizes\n    /** @type {?} */\n    var sizes = element.nodeName === 'HTML' ? getWindowSizes(element.ownerDocument) : {};\n    /** @type {?} */\n    var width = sizes.width || element.clientWidth || result.right - result.left;\n    /** @type {?} */\n    var height = sizes.height || element.clientHeight || result.bottom - result.top;\n    /** @type {?} */\n    var horizScrollbar = element.offsetWidth - width;\n    /** @type {?} */\n    var vertScrollbar = element.offsetHeight - height;\n    // if an hypothetical scrollbar is detected, we must be sure it's not a `border`\n    // we make this check conditional for performance reasons\n    if (horizScrollbar || vertScrollbar) {\n        /** @type {?} */\n        var styles = getStyleComputedProperty(element);\n        horizScrollbar -= getBordersSize(styles, 'x');\n        vertScrollbar -= getBordersSize(styles, 'y');\n        result.width -= horizScrollbar;\n        result.height -= vertScrollbar;\n    }\n    return getClientRect(result);\n}\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * @param {?} rect\n * @param {?} element\n * @param {?=} subtract\n * @return {?}\n */\nfunction includeScroll(rect, element, subtract) {\n    if (subtract === void 0) {\n        subtract = false;\n    }\n    /** @type {?} */\n    var scrollTop = getScroll(element, 'top');\n    /** @type {?} */\n    var scrollLeft = getScroll(element, 'left');\n    /** @type {?} */\n    var modifier = subtract ? -1 : 1;\n    rect.top += scrollTop * modifier;\n    rect.bottom += scrollTop * modifier;\n    rect.left += scrollLeft * modifier;\n    rect.right += scrollLeft * modifier;\n    return rect;\n}\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * @param {?} children\n * @param {?} parent\n * @param {?=} fixedPosition\n * @return {?}\n */\nfunction getOffsetRectRelativeToArbitraryNode(children, parent, fixedPosition) {\n    if (fixedPosition === void 0) {\n        fixedPosition = false;\n    }\n    /** @type {?} */\n    var isIE10 = isIE(10);\n    /** @type {?} */\n    var isHTML = parent.nodeName === 'HTML';\n    /** @type {?} */\n    var childrenRect = getBoundingClientRect(children);\n    /** @type {?} */\n    var parentRect = getBoundingClientRect(parent);\n    /** @type {?} */\n    var scrollParent = getScrollParent(children);\n    /** @type {?} */\n    var styles = getStyleComputedProperty(parent);\n    /** @type {?} */\n    var borderTopWidth = parseFloat(styles.borderTopWidth);\n    /** @type {?} */\n    var borderLeftWidth = parseFloat(styles.borderLeftWidth);\n    // In cases where the parent is fixed, we must ignore negative scroll in offset calc\n    if (fixedPosition && isHTML) {\n        parentRect.top = Math.max(parentRect.top, 0);\n        parentRect.left = Math.max(parentRect.left, 0);\n    }\n    /** @type {?} */\n    var offsets = getClientRect({\n        top: childrenRect.top - parentRect.top - borderTopWidth,\n        left: childrenRect.left - parentRect.left - borderLeftWidth,\n        width: childrenRect.width,\n        height: childrenRect.height\n    });\n    offsets.marginTop = 0;\n    offsets.marginLeft = 0;\n    // Subtract margins of documentElement in case it's being used as parent\n    // we do this only on HTML because it's the only element that behaves\n    // differently when margins are applied to it. The margins are included in\n    // the box of the documentElement, in the other cases not.\n    if (!isIE10 && isHTML) {\n        /** @type {?} */\n        var marginTop = parseFloat(styles.marginTop);\n        /** @type {?} */\n        var marginLeft = parseFloat(styles.marginLeft);\n        offsets.top -= borderTopWidth - marginTop;\n        offsets.bottom -= borderTopWidth - marginTop;\n        offsets.left -= borderLeftWidth - marginLeft;\n        offsets.right -= borderLeftWidth - marginLeft;\n        // Attach marginTop and marginLeft because in some circumstances we may need them\n        offsets.marginTop = marginTop;\n        offsets.marginLeft = marginLeft;\n    }\n    if (isIE10 && !fixedPosition\n        ? parent.contains(scrollParent)\n        : parent === scrollParent && scrollParent.nodeName !== 'BODY') {\n        offsets = includeScroll(offsets, parent);\n    }\n    return offsets;\n}\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * @param {?} element\n * @param {?=} excludeScroll\n * @return {?}\n */\nfunction getViewportOffsetRectRelativeToArtbitraryNode(element, excludeScroll) {\n    if (excludeScroll === void 0) {\n        excludeScroll = false;\n    }\n    /** @type {?} */\n    var html = element.ownerDocument.documentElement;\n    /** @type {?} */\n    var relativeOffset = getOffsetRectRelativeToArbitraryNode(element, html);\n    /** @type {?} */\n    var width = Math.max(html.clientWidth, window.innerWidth || 0);\n    /** @type {?} */\n    var height = Math.max(html.clientHeight, window.innerHeight || 0);\n    /** @type {?} */\n    var scrollTop = !excludeScroll ? getScroll(html) : 0;\n    /** @type {?} */\n    var scrollLeft = !excludeScroll ? getScroll(html, 'left') : 0;\n    /** @type {?} */\n    var offset = {\n        top: scrollTop - Number(relativeOffset.top) + Number(relativeOffset.marginTop),\n        left: scrollLeft - Number(relativeOffset.left) + Number(relativeOffset.marginLeft),\n        width: width,\n        height: height\n    };\n    return getClientRect(offset);\n}\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * @param {?} element\n * @return {?}\n */\nfunction isFixed(element) {\n    /** @type {?} */\n    var nodeName = element.nodeName;\n    if (nodeName === 'BODY' || nodeName === 'HTML') {\n        return false;\n    }\n    if (getStyleComputedProperty(element, 'position') === 'fixed') {\n        return true;\n    }\n    return isFixed(getParentNode(element));\n}\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * @param {?} element\n * @return {?}\n */\nfunction getFixedPositionOffsetParent(element) {\n    // This check is needed to avoid errors in case one of the elements isn't defined for any reason\n    if (!element || !element.parentElement || isIE()) {\n        return document.documentElement;\n    }\n    /** @type {?} */\n    var el = element.parentElement;\n    while (el && getStyleComputedProperty(el, 'transform') === 'none') {\n        el = el.parentElement;\n    }\n    return el || document.documentElement;\n}\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * @param {?} target\n * @param {?} host\n * @param {?=} padding\n * @param {?=} boundariesElement\n * @param {?=} fixedPosition\n * @return {?}\n */\nfunction getBoundaries(target, host, padding, boundariesElement, fixedPosition) {\n    // NOTE: 1 DOM access here\n    if (padding === void 0) {\n        padding = 0;\n    }\n    if (fixedPosition === void 0) {\n        fixedPosition = false;\n    }\n    // NOTE: 1 DOM access here\n    /** @type {?} */\n    var boundaries = { top: 0, left: 0 };\n    /** @type {?} */\n    var offsetParent = fixedPosition ? getFixedPositionOffsetParent(target) : findCommonOffsetParent(target, host);\n    // Handle viewport case\n    if (boundariesElement === 'viewport') {\n        boundaries = getViewportOffsetRectRelativeToArtbitraryNode(offsetParent, fixedPosition);\n    }\n    else {\n        // Handle other cases based on DOM element used as boundaries\n        /** @type {?} */\n        var boundariesNode = void 0;\n        if (boundariesElement === 'scrollParent') {\n            boundariesNode = getScrollParent(getParentNode(host));\n            if (boundariesNode.nodeName === 'BODY') {\n                boundariesNode = target.ownerDocument.documentElement;\n            }\n        }\n        else if (boundariesElement === 'window') {\n            boundariesNode = target.ownerDocument.documentElement;\n        }\n        else {\n            boundariesNode = boundariesElement;\n        }\n        /** @type {?} */\n        var offsets = getOffsetRectRelativeToArbitraryNode(boundariesNode, offsetParent, fixedPosition);\n        // In case of HTML, we need a different computation\n        if (boundariesNode.nodeName === 'HTML' && !isFixed(offsetParent)) {\n            var _a = getWindowSizes(target.ownerDocument), height = _a.height, width = _a.width;\n            boundaries.top += offsets.top - offsets.marginTop;\n            boundaries.bottom = Number(height) + Number(offsets.top);\n            boundaries.left += offsets.left - offsets.marginLeft;\n            boundaries.right = Number(width) + Number(offsets.left);\n        }\n        else {\n            // for all the other DOM elements, this one is good\n            boundaries = offsets;\n        }\n    }\n    // Add paddings\n    boundaries.left += padding;\n    boundaries.top += padding;\n    boundaries.right -= padding;\n    boundaries.bottom -= padding;\n    return boundaries;\n}\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * @param {?} __0\n * @return {?}\n */\nfunction getArea(_a) {\n    var width = _a.width, height = _a.height;\n    return width * height;\n}\n/**\n * @param {?} placement\n * @param {?} refRect\n * @param {?} target\n * @param {?} host\n * @param {?=} allowedPositions\n * @param {?=} boundariesElement\n * @param {?=} padding\n * @return {?}\n */\nfunction computeAutoPlacement(placement, refRect, target, host, allowedPositions, boundariesElement, padding) {\n    if (allowedPositions === void 0) {\n        allowedPositions = ['top', 'left', 'bottom', 'right'];\n    }\n    if (boundariesElement === void 0) {\n        boundariesElement = 'viewport';\n    }\n    if (padding === void 0) {\n        padding = 0;\n    }\n    if (placement.indexOf('auto') === -1) {\n        return placement;\n    }\n    /** @type {?} */\n    var boundaries = getBoundaries(target, host, padding, boundariesElement);\n    /** @type {?} */\n    var rects = {\n        top: {\n            width: boundaries.width,\n            height: refRect.top - boundaries.top\n        },\n        right: {\n            width: boundaries.right - refRect.right,\n            height: boundaries.height\n        },\n        bottom: {\n            width: boundaries.width,\n            height: boundaries.bottom - refRect.bottom\n        },\n        left: {\n            width: refRect.left - boundaries.left,\n            height: boundaries.height\n        }\n    };\n    /** @type {?} */\n    var sortedAreas = Object.keys(rects)\n        .map((function (key) { return (__assign({ key: key }, rects[key], { area: getArea(rects[key]) })); }))\n        .sort((function (a, b) { return b.area - a.area; }));\n    /** @type {?} */\n    var filteredAreas = sortedAreas.filter((function (_a) {\n        var width = _a.width, height = _a.height;\n        return width >= target.clientWidth && height >= target.clientHeight;\n    }));\n    filteredAreas = allowedPositions\n        .reduce((function (obj, key) {\n        var _a;\n        return __assign({}, obj, (_a = {}, _a[key] = filteredAreas[key], _a));\n    }), {});\n    /** @type {?} */\n    var computedPlacement = filteredAreas.length > 0\n        ? filteredAreas[0].key\n        : sortedAreas[0].key;\n    /** @type {?} */\n    var variation = placement.split(' ')[1];\n    target.className = target.className.replace(/auto/g, computedPlacement);\n    return computedPlacement + (variation ? \"-\" + variation : '');\n}\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * @param {?} data\n * @return {?}\n */\nfunction getOffsets(data) {\n    return {\n        width: data.offsets.target.width,\n        height: data.offsets.target.height,\n        left: Math.floor(data.offsets.target.left),\n        top: Math.round(data.offsets.target.top),\n        bottom: Math.round(data.offsets.target.bottom),\n        right: Math.floor(data.offsets.target.right)\n    };\n}\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * Get the opposite placement of the given one\n * @param {?} placement\n * @return {?}\n */\nfunction getOppositePlacement(placement) {\n    /** @type {?} */\n    var hash = { left: 'right', right: 'left', bottom: 'top', top: 'bottom' };\n    return placement.replace(/left|right|bottom|top/g, (function (matched) { return (((hash)))[matched]; }));\n}\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * Get the opposite placement variation of the given one\n * @param {?} variation\n * @return {?}\n */\nfunction getOppositeVariation(variation) {\n    if (variation === 'right') {\n        return 'left';\n    }\n    else if (variation === 'left') {\n        return 'right';\n    }\n    return variation;\n}\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * Get the outer sizes of the given element (offset size + margins)\n * @param {?} element\n * @return {?}\n */\nfunction getOuterSizes(element) {\n    /** @type {?} */\n    var window = element.ownerDocument.defaultView;\n    /** @type {?} */\n    var styles = window.getComputedStyle(element);\n    /** @type {?} */\n    var x = parseFloat(styles.marginTop || 0) + parseFloat(styles.marginBottom || 0);\n    /** @type {?} */\n    var y = parseFloat(styles.marginLeft || 0) + parseFloat(styles.marginRight || 0);\n    return {\n        width: Number(element.offsetWidth) + y,\n        height: Number(element.offsetHeight) + x\n    };\n}\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * @param {?} target\n * @param {?} host\n * @param {?=} fixedPosition\n * @return {?}\n */\nfunction getReferenceOffsets(target, host, fixedPosition) {\n    if (fixedPosition === void 0) {\n        fixedPosition = null;\n    }\n    /** @type {?} */\n    var commonOffsetParent = fixedPosition\n        ? getFixedPositionOffsetParent(target)\n        : findCommonOffsetParent(target, host);\n    return getOffsetRectRelativeToArbitraryNode(host, commonOffsetParent, fixedPosition);\n}\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * @param {?} target\n * @param {?} hostOffsets\n * @param {?} position\n * @return {?}\n */\nfunction getTargetOffsets(target, hostOffsets, position) {\n    /** @type {?} */\n    var placement = position.split(' ')[0];\n    // Get target node sizes\n    /** @type {?} */\n    var targetRect = getOuterSizes(target);\n    // Add position, width and height to our offsets object\n    /** @type {?} */\n    var targetOffsets = {\n        width: targetRect.width,\n        height: targetRect.height\n    };\n    // depending by the target placement we have to compute its offsets slightly differently\n    /** @type {?} */\n    var isHoriz = ['right', 'left'].indexOf(placement) !== -1;\n    /** @type {?} */\n    var mainSide = isHoriz ? 'top' : 'left';\n    /** @type {?} */\n    var secondarySide = isHoriz ? 'left' : 'top';\n    /** @type {?} */\n    var measurement = isHoriz ? 'height' : 'width';\n    /** @type {?} */\n    var secondaryMeasurement = !isHoriz ? 'height' : 'width';\n    (((targetOffsets)))[mainSide] =\n        hostOffsets[mainSide] +\n            hostOffsets[measurement] / 2 -\n            targetRect[measurement] / 2;\n    (((targetOffsets)))[secondarySide] = placement === secondarySide\n        ? hostOffsets[secondarySide] - targetRect[secondaryMeasurement]\n        : (((hostOffsets)))[getOppositePlacement(secondarySide)];\n    return targetOffsets;\n}\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * Helper used to know if the given modifier is enabled.\n * @param {?} options\n * @param {?} modifierName\n * @return {?}\n */\nfunction isModifierEnabled(options, modifierName) {\n    return options\n        && options.modifiers\n        && options.modifiers[modifierName]\n        && options.modifiers[modifierName].enabled;\n}\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * Tells if a given input is a number\n * @param {?} n\n * @return {?}\n */\nfunction isNumeric(n) {\n    return n !== '' && !isNaN(parseFloat(n)) && isFinite(n);\n}\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * @param {?} element\n * @param {?} styles\n * @param {?=} renderer\n * @return {?}\n */\nfunction setStyles(element, styles, renderer) {\n    Object.keys(styles).forEach((function (prop) {\n        /** @type {?} */\n        var unit = '';\n        // add unit if the value is numeric and is one of the following\n        if (['width', 'height', 'top', 'right', 'bottom', 'left'].indexOf(prop) !== -1 &&\n            isNumeric(styles[prop])) {\n            unit = 'px';\n        }\n        if (renderer) {\n            renderer.setStyle(element, prop, \"\" + String(styles[prop]) + unit);\n            return;\n        }\n        element.style[prop] = String(styles[prop]) + unit;\n    }));\n}\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * @param {?} data\n * @param {?=} renderer\n * @return {?}\n */\nfunction setAllStyles(data, renderer) {\n    /** @type {?} */\n    var target = data.instance.target;\n    /** @type {?} */\n    var offsets = getOffsets(data);\n    setStyles(target, {\n        'will-change': 'transform',\n        top: '0px',\n        left: '0px',\n        transform: \"translate3d(\" + offsets.left + \"px, \" + offsets.top + \"px, 0px)\"\n    }, renderer);\n    if (data.instance.arrow) {\n        setStyles(data.instance.arrow, data.offsets.arrow, renderer);\n    }\n    if (data.placementAuto) {\n        if (renderer) {\n            renderer.setAttribute(target, 'class', target.className.replace(/bs-popover-auto/g, \"bs-popover-\" + data.placement));\n            renderer.setAttribute(target, 'class', target.className.replace(/bs-tooltip-auto/g, \"bs-tooltip-\" + data.placement));\n            renderer.setAttribute(target, 'class', target.className.replace(/\\sauto/g, \"s\" + data.placement));\n            if (target.className.match(/popover/g)) {\n                renderer.addClass(target, 'popover-auto');\n            }\n            if (target.className.match(/tooltip/g)) {\n                renderer.addClass(target, 'tooltip-auto');\n            }\n        }\n        else {\n            target.className = target.className.replace(/bs-popover-auto/g, \"bs-popover-\" + data.placement);\n            target.className = target.className.replace(/bs-tooltip-auto/g, \"bs-tooltip-\" + data.placement);\n            target.className = target.className.replace(/\\sauto/g, \"s\" + data.placement);\n            if (target.className.match(/popover/g)) {\n                target.classList.add('popover-auto');\n            }\n            if (target.className.match(/tooltip/g)) {\n                target.classList.add('tooltip-auto');\n            }\n        }\n    }\n    if (renderer) {\n        renderer.setAttribute(target, 'class', target.className.replace(/left|right|top|bottom/g, \"\" + data.placement.split(' ')[0]));\n    }\n    else {\n        target.className = target.className.replace(/left|right|top|bottom/g, \"\" + data.placement.split(' ')[0]);\n    }\n}\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * @param {?} data\n * @return {?}\n */\nfunction arrow(data) {\n    var _a;\n    /** @type {?} */\n    var targetOffsets = data.offsets.target;\n    // if arrowElement is a string, suppose it's a CSS selector\n    /** @type {?} */\n    var arrowElement = data.instance.target.querySelector('.arrow');\n    // if arrowElement is not found, don't run the modifier\n    if (!arrowElement) {\n        return data;\n    }\n    /** @type {?} */\n    var isVertical = ['left', 'right'].indexOf(data.placement) !== -1;\n    /** @type {?} */\n    var len = isVertical ? 'height' : 'width';\n    /** @type {?} */\n    var sideCapitalized = isVertical ? 'Top' : 'Left';\n    /** @type {?} */\n    var side = sideCapitalized.toLowerCase();\n    /** @type {?} */\n    var altSide = isVertical ? 'left' : 'top';\n    /** @type {?} */\n    var opSide = isVertical ? 'bottom' : 'right';\n    /** @type {?} */\n    var arrowElementSize = getOuterSizes(arrowElement)[len];\n    // top/left side\n    if (data.offsets.host[opSide] - arrowElementSize < (((targetOffsets)))[side]) {\n        (((targetOffsets)))[side] -=\n            (((targetOffsets)))[side] - (data.offsets.host[opSide] - arrowElementSize);\n    }\n    // bottom/right side\n    if (Number((((data))).offsets.host[side]) + Number(arrowElementSize) > (((targetOffsets)))[opSide]) {\n        (((targetOffsets)))[side] +=\n            Number((((data))).offsets.host[side]) + Number(arrowElementSize) - Number((((targetOffsets)))[opSide]);\n    }\n    targetOffsets = getClientRect(targetOffsets);\n    // compute center of the target\n    /** @type {?} */\n    var center = Number((((data))).offsets.host[side]) + Number(data.offsets.host[len] / 2 - arrowElementSize / 2);\n    // Compute the sideValue using the updated target offsets\n    // take target margin in account because we don't have this info available\n    /** @type {?} */\n    var css = getStyleComputedProperty(data.instance.target);\n    /** @type {?} */\n    var targetMarginSide = parseFloat(css[\"margin\" + sideCapitalized]);\n    /** @type {?} */\n    var targetBorderSide = parseFloat(css[\"border\" + sideCapitalized + \"Width\"]);\n    /** @type {?} */\n    var sideValue = center - (((targetOffsets)))[side] - targetMarginSide - targetBorderSide;\n    // prevent arrowElement from being placed not contiguously to its target\n    sideValue = Math.max(Math.min(targetOffsets[len] - arrowElementSize, sideValue), 0);\n    data.offsets.arrow = (_a = {},\n        _a[side] = Math.round(sideValue),\n        _a[altSide] = '' // make sure to unset any eventual altSide value from the DOM node\n        ,\n            _a);\n    data.instance.arrow = arrowElement;\n    return data;\n}\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * @param {?} data\n * @return {?}\n */\nfunction flip(data) {\n    data.offsets.target = getClientRect(data.offsets.target);\n    if (!isModifierEnabled(data.options, 'flip')) {\n        data.offsets.target = __assign({}, data.offsets.target, getTargetOffsets(data.instance.target, data.offsets.host, data.placement));\n        return data;\n    }\n    /** @type {?} */\n    var boundaries = getBoundaries(data.instance.target, data.instance.host, 0, // padding\n    'viewport', false // positionFixed\n    );\n    /** @type {?} */\n    var placement = data.placement.split(' ')[0];\n    /** @type {?} */\n    var variation = data.placement.split(' ')[1] || '';\n    /** @type {?} */\n    var offsetsHost = data.offsets.host;\n    /** @type {?} */\n    var target = data.instance.target;\n    /** @type {?} */\n    var host = data.instance.host;\n    /** @type {?} */\n    var adaptivePosition = variation\n        ? computeAutoPlacement('auto', offsetsHost, target, host, ['top', 'bottom'])\n        : computeAutoPlacement('auto', offsetsHost, target, host);\n    /** @type {?} */\n    var flipOrder = [placement, adaptivePosition];\n    /* tslint:disable-next-line: cyclomatic-complexity */\n    flipOrder.forEach((function (step, index) {\n        if (placement !== step || flipOrder.length === index + 1) {\n            return data;\n        }\n        placement = data.placement.split(' ')[0];\n        // using floor because the host offsets may contain decimals we are not going to consider here\n        /** @type {?} */\n        var overlapsRef = (placement === 'left' &&\n            Math.floor(data.offsets.target.right) > Math.floor(data.offsets.host.left)) ||\n            (placement === 'right' &&\n                Math.floor(data.offsets.target.left) < Math.floor(data.offsets.host.right)) ||\n            (placement === 'top' &&\n                Math.floor(data.offsets.target.bottom) > Math.floor(data.offsets.host.top)) ||\n            (placement === 'bottom' &&\n                Math.floor(data.offsets.target.top) < Math.floor(data.offsets.host.bottom));\n        /** @type {?} */\n        var overflowsLeft = Math.floor(data.offsets.target.left) < Math.floor(boundaries.left);\n        /** @type {?} */\n        var overflowsRight = Math.floor(data.offsets.target.right) > Math.floor(boundaries.right);\n        /** @type {?} */\n        var overflowsTop = Math.floor(data.offsets.target.top) < Math.floor(boundaries.top);\n        /** @type {?} */\n        var overflowsBottom = Math.floor(data.offsets.target.bottom) > Math.floor(boundaries.bottom);\n        /** @type {?} */\n        var overflowsBoundaries = (placement === 'left' && overflowsLeft) ||\n            (placement === 'right' && overflowsRight) ||\n            (placement === 'top' && overflowsTop) ||\n            (placement === 'bottom' && overflowsBottom);\n        // flip the variation if required\n        /** @type {?} */\n        var isVertical = ['top', 'bottom'].indexOf(placement) !== -1;\n        /** @type {?} */\n        var flippedVariation = ((isVertical && variation === 'left' && overflowsLeft) ||\n            (isVertical && variation === 'right' && overflowsRight) ||\n            (!isVertical && variation === 'left' && overflowsTop) ||\n            (!isVertical && variation === 'right' && overflowsBottom));\n        if (overlapsRef || overflowsBoundaries || flippedVariation) {\n            if (overlapsRef || overflowsBoundaries) {\n                placement = flipOrder[index + 1];\n            }\n            if (flippedVariation) {\n                variation = getOppositeVariation(variation);\n            }\n            data.placement = placement + (variation ? \" \" + variation : '');\n            data.offsets.target = __assign({}, data.offsets.target, getTargetOffsets(data.instance.target, data.offsets.host, data.placement));\n        }\n    }));\n    return data;\n}\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * @param {?} targetElement\n * @param {?} hostElement\n * @param {?} position\n * @param {?} options\n * @return {?}\n */\nfunction initData(targetElement, hostElement, position, options) {\n    /** @type {?} */\n    var hostElPosition = getReferenceOffsets(targetElement, hostElement);\n    /** @type {?} */\n    var placementAuto = !!position.match(/auto/g);\n    // support old placements 'auto left|right|top|bottom'\n    /** @type {?} */\n    var placement = !!position.match(/auto\\s(left|right|top|bottom)/g)\n        ? position.split(' ')[1] || ''\n        : position;\n    /** @type {?} */\n    var targetOffset = getTargetOffsets(targetElement, hostElPosition, placement);\n    placement = computeAutoPlacement(placement, hostElPosition, targetElement, hostElement);\n    return {\n        options: options,\n        instance: {\n            target: targetElement,\n            host: hostElement,\n            arrow: null\n        },\n        offsets: {\n            target: targetOffset,\n            host: hostElPosition,\n            arrow: null\n        },\n        positionFixed: false,\n        placement: placement,\n        placementAuto: placementAuto\n    };\n}\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * @param {?} data\n * @return {?}\n */\nfunction preventOverflow(data) {\n    if (!isModifierEnabled(data.options, 'preventOverflow')) {\n        return data;\n    }\n    // NOTE: DOM access here\n    // resets the targetOffsets's position so that the document size can be calculated excluding\n    // the size of the targetOffsets element itself\n    /** @type {?} */\n    var transformProp = 'transform';\n    /** @type {?} */\n    var targetStyles = data.instance.target.style;\n    // assignment to help minification\n    var top = targetStyles.top, left = targetStyles.left, _a = transformProp, transform = targetStyles[_a];\n    targetStyles.top = '';\n    targetStyles.left = '';\n    targetStyles[transformProp] = '';\n    /** @type {?} */\n    var boundaries = getBoundaries(data.instance.target, data.instance.host, 0, // padding\n    'scrollParent', false // positionFixed\n    );\n    // NOTE: DOM access here\n    // restores the original style properties after the offsets have been computed\n    targetStyles.top = top;\n    targetStyles.left = left;\n    targetStyles[transformProp] = transform;\n    /** @type {?} */\n    var order = ['left', 'right', 'top', 'bottom'];\n    /** @type {?} */\n    var check = {\n        primary: /**\n         * @param {?} placement\n         * @return {?}\n         */ function (placement) {\n            var _a;\n            /** @type {?} */\n            var value = (((data))).offsets.target[placement];\n            if ((((data))).offsets.target[placement] < boundaries[placement] &&\n                !false // options.escapeWithReference\n            ) {\n                value = Math.max((((data))).offsets.target[placement], boundaries[placement]);\n            }\n            return _a = {}, _a[placement] = value, _a;\n        },\n        secondary: /**\n         * @param {?} placement\n         * @return {?}\n         */ function (placement) {\n            var _a;\n            /** @type {?} */\n            var mainSide = placement === 'right' ? 'left' : 'top';\n            /** @type {?} */\n            var value = data.offsets.target[mainSide];\n            if ((((data))).offsets.target[placement] > boundaries[placement] &&\n                !false // escapeWithReference\n            ) {\n                value = Math.min(data.offsets.target[mainSide], boundaries[placement] -\n                    (placement === 'right' ? data.offsets.target.width : data.offsets.target.height));\n            }\n            return _a = {}, _a[mainSide] = value, _a;\n        }\n    };\n    /** @type {?} */\n    var side;\n    order.forEach((function (placement) {\n        side = ['left', 'top']\n            .indexOf(placement) !== -1\n            ? 'primary'\n            : 'secondary';\n        data.offsets.target = __assign({}, data.offsets.target, (((check)))[side](placement));\n    }));\n    return data;\n}\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * @param {?} data\n * @return {?}\n */\nfunction shift(data) {\n    var _a, _b;\n    /** @type {?} */\n    var placement = data.placement;\n    /** @type {?} */\n    var basePlacement = placement.split(' ')[0];\n    /** @type {?} */\n    var shiftvariation = placement.split(' ')[1];\n    if (shiftvariation) {\n        var _c = data.offsets, host = _c.host, target = _c.target;\n        /** @type {?} */\n        var isVertical = ['bottom', 'top'].indexOf(basePlacement) !== -1;\n        /** @type {?} */\n        var side = isVertical ? 'left' : 'top';\n        /** @type {?} */\n        var measurement = isVertical ? 'width' : 'height';\n        /** @type {?} */\n        var shiftOffsets = {\n            left: (_a = {}, _a[side] = host[side], _a),\n            right: (_b = {},\n                _b[side] = host[side] + host[measurement] - host[measurement],\n                _b)\n        };\n        data.offsets.target = __assign({}, target, (((shiftOffsets)))[shiftvariation]);\n    }\n    return data;\n}\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\nvar Positioning = /*@__PURE__*/ (function () {\n    function Positioning() {\n    }\n    /**\n     * @param {?} hostElement\n     * @param {?} targetElement\n     * @return {?}\n     */\n    Positioning.prototype.position = /**\n     * @param {?} hostElement\n     * @param {?} targetElement\n     * @return {?}\n     */\n        function (hostElement, targetElement) {\n            return this.offset(hostElement, targetElement);\n        };\n    /**\n     * @param {?} hostElement\n     * @param {?} targetElement\n     * @return {?}\n     */\n    Positioning.prototype.offset = /**\n     * @param {?} hostElement\n     * @param {?} targetElement\n     * @return {?}\n     */\n        function (hostElement, targetElement) {\n            return getReferenceOffsets(targetElement, hostElement);\n        };\n    /**\n     * @param {?} hostElement\n     * @param {?} targetElement\n     * @param {?} position\n     * @param {?=} _appendToBody\n     * @param {?=} options\n     * @return {?}\n     */\n    Positioning.prototype.positionElements = /**\n     * @param {?} hostElement\n     * @param {?} targetElement\n     * @param {?} position\n     * @param {?=} _appendToBody\n     * @param {?=} options\n     * @return {?}\n     */\n        function (hostElement, targetElement, position, _appendToBody, options) {\n            /** @type {?} */\n            var chainOfModifiers = [flip, shift, preventOverflow, arrow];\n            return chainOfModifiers.reduce((function (modifiedData, modifier) { return modifier(modifiedData); }), initData(targetElement, hostElement, position, options));\n        };\n    return Positioning;\n}());\n/** @type {?} */\nvar positionService = new Positioning();\n/**\n * @param {?} hostElement\n * @param {?} targetElement\n * @param {?} placement\n * @param {?=} appendToBody\n * @param {?=} options\n * @param {?=} renderer\n * @return {?}\n */\nfunction positionElements(hostElement, targetElement, placement, appendToBody, options, renderer) {\n    /** @type {?} */\n    var data = positionService.positionElements(hostElement, targetElement, placement, appendToBody, options);\n    setAllStyles(data, renderer);\n}\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\nvar PositioningService = /*@__PURE__*/ (function () {\n    function PositioningService(rendererFactory, platformId) {\n        var _this = this;\n        this.update$$ = new Subject();\n        this.positionElements = new Map();\n        if (isPlatformBrowser(platformId)) {\n            merge(fromEvent(window, 'scroll'), fromEvent(window, 'resize'), \n            // tslint:disable-next-line: deprecation\n            of(0, animationFrameScheduler), this.update$$).subscribe((function () {\n                _this.positionElements.forEach((function (positionElement) {\n                    positionElements(_getHtmlElement(positionElement.target), _getHtmlElement(positionElement.element), positionElement.attachment, positionElement.appendToBody, _this.options, rendererFactory.createRenderer(null, null));\n                }));\n            }));\n        }\n    }\n    /**\n     * @param {?} options\n     * @return {?}\n     */\n    PositioningService.prototype.position = /**\n     * @param {?} options\n     * @return {?}\n     */\n        function (options) {\n            this.addPositionElement(options);\n        };\n    /**\n     * @param {?} options\n     * @return {?}\n     */\n    PositioningService.prototype.addPositionElement = /**\n     * @param {?} options\n     * @return {?}\n     */\n        function (options) {\n            this.positionElements.set(_getHtmlElement(options.element), options);\n        };\n    /**\n     * @return {?}\n     */\n    PositioningService.prototype.calcPosition = /**\n     * @return {?}\n     */\n        function () {\n            this.update$$.next();\n        };\n    /**\n     * @param {?} elRef\n     * @return {?}\n     */\n    PositioningService.prototype.deletePositionElement = /**\n     * @param {?} elRef\n     * @return {?}\n     */\n        function (elRef) {\n            this.positionElements.delete(_getHtmlElement(elRef));\n        };\n    /**\n     * @param {?} options\n     * @return {?}\n     */\n    PositioningService.prototype.setOptions = /**\n     * @param {?} options\n     * @return {?}\n     */\n        function (options) {\n            this.options = options;\n        };\n    return PositioningService;\n}());\n/**\n * @param {?} element\n * @return {?}\n */\nfunction _getHtmlElement(element) {\n    // it means that we got a selector\n    if (element && typeof element === 'string') {\n        return document.querySelector(element);\n    }\n    if (element instanceof ElementRef) {\n        return element.nativeElement;\n    }\n    return element;\n}\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\nvar ComponentLoaderFactory = /*@__PURE__*/ (function () {\n    function ComponentLoaderFactory(_componentFactoryResolver, _ngZone, _injector, _posService, _applicationRef) {\n        this._componentFactoryResolver = _componentFactoryResolver;\n        this._ngZone = _ngZone;\n        this._injector = _injector;\n        this._posService = _posService;\n        this._applicationRef = _applicationRef;\n    }\n    /**\n     * @template T\n     * @param {?} _elementRef\n     * @param {?} _viewContainerRef\n     * @param {?} _renderer\n     * @return {?}\n     */\n    ComponentLoaderFactory.prototype.createLoader = /**\n     * @template T\n     * @param {?} _elementRef\n     * @param {?} _viewContainerRef\n     * @param {?} _renderer\n     * @return {?}\n     */\n        function (_elementRef, _viewContainerRef, _renderer) {\n            return new ComponentLoader(_viewContainerRef, _renderer, _elementRef, this._injector, this._componentFactoryResolver, this._ngZone, this._applicationRef, this._posService);\n        };\n    return ComponentLoaderFactory;\n}());\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * Default dropdown configuration\n */\nvar BsDropdownConfig = /*@__PURE__*/ (function () {\n    function BsDropdownConfig() {\n        /**\n         * default dropdown auto closing behavior\n         */\n        this.autoClose = true;\n    }\n    return BsDropdownConfig;\n}());\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\nvar BsDropdownState = /*@__PURE__*/ (function () {\n    function BsDropdownState() {\n        var _this = this;\n        this.direction = 'down';\n        this.isOpenChange = new EventEmitter();\n        this.isDisabledChange = new EventEmitter();\n        this.toggleClick = new EventEmitter();\n        this.dropdownMenu = new Promise((function (resolve) {\n            _this.resolveDropdownMenu = resolve;\n        }));\n    }\n    return BsDropdownState;\n}());\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\nvar BsDropdownContainerComponent = /*@__PURE__*/ (function () {\n    function BsDropdownContainerComponent(_state) {\n        var _this = this;\n        this._state = _state;\n        this.isOpen = false;\n        this.display = 'block';\n        this.position = 'absolute';\n        this._subscription = _state.isOpenChange.subscribe((function (value) {\n            _this.isOpen = value;\n        }));\n    }\n    Object.defineProperty(BsDropdownContainerComponent.prototype, \"direction\", {\n        get: /**\n         * @return {?}\n         */ function () {\n            return this._state.direction;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * @return {?}\n     */\n    BsDropdownContainerComponent.prototype.ngOnDestroy = /**\n     * @return {?}\n     */\n        function () {\n            this._subscription.unsubscribe();\n        };\n    return BsDropdownContainerComponent;\n}());\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\nvar BsDropdownDirective = /*@__PURE__*/ (function () {\n    function BsDropdownDirective(_elementRef, _renderer, _viewContainerRef, _cis, _config, _state) {\n        this._elementRef = _elementRef;\n        this._renderer = _renderer;\n        this._viewContainerRef = _viewContainerRef;\n        this._cis = _cis;\n        this._config = _config;\n        this._state = _state;\n        // todo: move to component loader\n        this._isInlineOpen = false;\n        this._subscriptions = [];\n        this._isInited = false;\n        // create dropdown component loader\n        this._dropdown = this._cis\n            .createLoader(this._elementRef, this._viewContainerRef, this._renderer)\n            .provide({ provide: BsDropdownState, useValue: this._state });\n        this.onShown = this._dropdown.onShown;\n        this.shown = this._dropdown.shown;\n        this.onHidden = this._dropdown.onHidden;\n        this.hidden = this._dropdown.hidden;\n        this.isOpenChange = this._state.isOpenChange;\n        // set initial dropdown state from config\n        this._state.autoClose = this._config.autoClose;\n    }\n    Object.defineProperty(BsDropdownDirective.prototype, \"autoClose\", {\n        get: /**\n         * @return {?}\n         */ function () {\n            return this._state.autoClose;\n        },\n        /**\n         * Indicates that dropdown will be closed on item or document click,\n         * and after pressing ESC\n         */\n        set: /**\n         * Indicates that dropdown will be closed on item or document click,\n         * and after pressing ESC\n         * @param {?} value\n         * @return {?}\n         */ function (value) {\n            if (typeof value === 'boolean') {\n                this._state.autoClose = value;\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(BsDropdownDirective.prototype, \"isDisabled\", {\n        get: /**\n         * @return {?}\n         */ function () {\n            return this._isDisabled;\n        },\n        /**\n         * Disables dropdown toggle and hides dropdown menu if opened\n         */\n        set: /**\n         * Disables dropdown toggle and hides dropdown menu if opened\n         * @param {?} value\n         * @return {?}\n         */ function (value) {\n            this._isDisabled = value;\n            this._state.isDisabledChange.emit(value);\n            if (value) {\n                this.hide();\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(BsDropdownDirective.prototype, \"isOpen\", {\n        /**\n         * Returns whether or not the popover is currently being shown\n         */\n        get: /**\n         * Returns whether or not the popover is currently being shown\n         * @return {?}\n         */ function () {\n            if (this._showInline) {\n                return this._isInlineOpen;\n            }\n            return this._dropdown.isShown;\n        },\n        set: /**\n         * @param {?} value\n         * @return {?}\n         */ function (value) {\n            if (value) {\n                this.show();\n            }\n            else {\n                this.hide();\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(BsDropdownDirective.prototype, \"isBs4\", {\n        get: /**\n         * @return {?}\n         */ function () {\n            return !isBs3();\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * @return {?}\n     */\n    BsDropdownDirective.prototype.ngOnInit = /**\n     * @return {?}\n     */\n        function () {\n            var _this = this;\n            // fix: seems there are an issue with `routerLinkActive`\n            // which result in duplicated call ngOnInit without call to ngOnDestroy\n            // read more: https://github.com/valor-software/ngx-bootstrap/issues/1885\n            if (this._isInited) {\n                return;\n            }\n            this._isInited = true;\n            this._showInline = !this.container;\n            // attach DOM listeners\n            this._dropdown.listen({\n                triggers: this.triggers,\n                show: (function () { return _this.show(); }),\n            });\n            // toggle visibility on toggle element click\n            this._subscriptions.push(this._state.toggleClick.subscribe((function (value) { return _this.toggle(value); })));\n            // hide dropdown if set disabled while opened\n            this._subscriptions.push(this._state.isDisabledChange.subscribe((function (element) {\n                if (element === true) {\n                    _this.hide();\n                }\n            })));\n            // attach dropdown menu inside of dropdown\n            if (this._showInline) {\n                this._state.dropdownMenu.then((function (dropdownMenu) {\n                    _this._inlinedMenu = dropdownMenu.viewContainer.createEmbeddedView(dropdownMenu.templateRef);\n                }));\n            }\n            this._state.isOpenChange.subscribe((function () {\n                setTimeout((function () {\n                    /** @type {?} */\n                    var dropdownContainer = _this._elementRef.nativeElement.querySelector('.dropdown-menu');\n                    /** @type {?} */\n                    var left = dropdownContainer.getBoundingClientRect().left;\n                    if (dropdownContainer.classList.contains('dropdown-menu-right') &&\n                        left <= dropdownContainer.clientWidth) {\n                        if (left < 0) {\n                            _this._renderer.setStyle(dropdownContainer, 'right', left + 'px');\n                        }\n                        else {\n                            _this._renderer.setStyle(dropdownContainer, 'right', '0');\n                        }\n                    }\n                }), 0);\n            }));\n        };\n    /**\n     * Opens an element’s popover. This is considered a “manual” triggering of\n     * the popover.\n     */\n    /**\n     * Opens an element’s popover. This is considered a “manual” triggering of\n     * the popover.\n     * @return {?}\n     */\n    BsDropdownDirective.prototype.show = /**\n     * Opens an element’s popover. This is considered a “manual” triggering of\n     * the popover.\n     * @return {?}\n     */\n        function () {\n            var _this = this;\n            if (this.isOpen || this.isDisabled) {\n                return;\n            }\n            // material and dropup dropdown animation\n            // const parent = this._elementRef.nativeElement.classList;\n            /** @type {?} */\n            var container = this._elementRef.nativeElement.querySelector('.dropdown-menu');\n            setTimeout((function () {\n                container.classList.add('fadeInDropdown');\n            }), 200);\n            if (this._showInline) {\n                this._isInlineOpen = true;\n                this.onShown.emit(true);\n                this.shown.emit(true);\n                this._state.isOpenChange.emit(true);\n                return;\n            }\n            this._state.dropdownMenu.then((function (dropdownMenu) {\n                // check direction in which dropdown should be opened\n                /** @type {?} */\n                var _dropup = _this.dropup === true || (typeof _this.dropup !== 'undefined' && _this.dropup !== false);\n                _this._state.direction = _dropup ? 'up' : 'down';\n                /** @type {?} */\n                var _placement = _this.placement || (_dropup ? 'top left' : 'bottom left');\n                // show dropdown\n                _this._dropdown\n                    .attach(BsDropdownContainerComponent)\n                    .to(_this.container)\n                    .position({ attachment: _placement })\n                    .show({\n                    content: dropdownMenu.templateRef,\n                    placement: _placement,\n                });\n                _this._state.isOpenChange.emit(true);\n            }));\n        };\n    /**\n     * Closes an element’s popover. This is considered a “manual” triggering of\n     * the popover.\n     */\n    /**\n     * Closes an element’s popover. This is considered a “manual” triggering of\n     * the popover.\n     * @return {?}\n     */\n    BsDropdownDirective.prototype.hide = /**\n     * Closes an element’s popover. This is considered a “manual” triggering of\n     * the popover.\n     * @return {?}\n     */\n        function () {\n            var _this = this;\n            if (!this.isOpen) {\n                return;\n            }\n            /** @type {?} */\n            var parent = this._elementRef.nativeElement.classList;\n            /** @type {?} */\n            var container = this._elementRef.nativeElement.querySelector('.dropdown-menu');\n            if (parent.value === 'dropdown open show' || parent.value === 'btn-group dropup open show') {\n                container.classList.remove('fadeInDropdown');\n                setTimeout((function () {\n                    if (_this._showInline) {\n                        _this._isInlineOpen = false;\n                        _this.onHidden.emit(true);\n                        _this.hidden.emit(true);\n                    }\n                    else {\n                        _this._dropdown.hide();\n                    }\n                    _this._state.isOpenChange.emit(false);\n                }), 560);\n            }\n            else {\n                if (this._showInline) {\n                    this._isInlineOpen = false;\n                    this.onHidden.emit(true);\n                    this.hidden.emit(true);\n                }\n                else {\n                    this._dropdown.hide();\n                }\n                this._state.isOpenChange.emit(false);\n            }\n        };\n    /**\n     * Toggles an element’s popover. This is considered a “manual” triggering of\n     * the popover.\n     */\n    /**\n     * Toggles an element’s popover. This is considered a “manual” triggering of\n     * the popover.\n     * @param {?=} value\n     * @return {?}\n     */\n    BsDropdownDirective.prototype.toggle = /**\n     * Toggles an element’s popover. This is considered a “manual” triggering of\n     * the popover.\n     * @param {?=} value\n     * @return {?}\n     */\n        function (value) {\n            if (this.isOpen || value === false) {\n                return this.hide();\n            }\n            return this.show();\n        };\n    /**\n     * @return {?}\n     */\n    BsDropdownDirective.prototype.ngOnDestroy = /**\n     * @return {?}\n     */\n        function () {\n            var e_1, _a;\n            try {\n                // clean up subscriptions and destroy dropdown\n                for (var _b = __values(this._subscriptions), _c = _b.next(); !_c.done; _c = _b.next()) {\n                    var sub = _c.value;\n                    sub.unsubscribe();\n                }\n            }\n            catch (e_1_1) {\n                e_1 = { error: e_1_1 };\n            }\n            finally {\n                try {\n                    if (_c && !_c.done && (_a = _b.return))\n                        _a.call(_b);\n                }\n                finally {\n                    if (e_1)\n                        throw e_1.error;\n                }\n            }\n            this._dropdown.dispose();\n        };\n    return BsDropdownDirective;\n}());\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\nvar BsDropdownMenuDirective = /*@__PURE__*/ (function () {\n    function BsDropdownMenuDirective(_state, _viewContainer, _templateRef) {\n        _state.resolveDropdownMenu({\n            templateRef: _templateRef,\n            viewContainer: _viewContainer\n        });\n    }\n    return BsDropdownMenuDirective;\n}());\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\nvar BsDropdownToggleDirective = /*@__PURE__*/ (function () {\n    function BsDropdownToggleDirective(_state, _element) {\n        var _this = this;\n        this._state = _state;\n        this._element = _element;\n        this._subscriptions = [];\n        this.ariaHaspopup = true;\n        // @HostBinding('attr.disabled') isDisabled: boolean = null;\n        this.isDisabled = null;\n        // sync is open value with state\n        this._subscriptions.push(this._state\n            .isOpenChange.subscribe((function (value) { return _this.isOpen = value; })));\n        // populate disabled state\n        this._subscriptions.push(this._state\n            .isDisabledChange\n            .subscribe((function (value) { return _this.isDisabled = value || null; })));\n    }\n    /**\n     * @return {?}\n     */\n    BsDropdownToggleDirective.prototype.onClick = /**\n     * @return {?}\n     */\n        function () {\n            if (this.isDisabled) {\n                return;\n            }\n            this._state.toggleClick.emit();\n        };\n    /**\n     * @param {?} event\n     * @return {?}\n     */\n    BsDropdownToggleDirective.prototype.onDocumentClick = /**\n     * @param {?} event\n     * @return {?}\n     */\n        function (event) {\n            if (this._state.autoClose && event.button !== 2 &&\n                !this._element.nativeElement.contains(event.target)) {\n                this._state.toggleClick.emit(false);\n            }\n        };\n    /**\n     * @return {?}\n     */\n    BsDropdownToggleDirective.prototype.onEsc = /**\n     * @return {?}\n     */\n        function () {\n            if (this._state.autoClose) {\n                this._state.toggleClick.emit(false);\n            }\n        };\n    /**\n     * @return {?}\n     */\n    BsDropdownToggleDirective.prototype.ngOnDestroy = /**\n     * @return {?}\n     */\n        function () {\n            var e_1, _a;\n            try {\n                for (var _b = __values(this._subscriptions), _c = _b.next(); !_c.done; _c = _b.next()) {\n                    var sub = _c.value;\n                    sub.unsubscribe();\n                }\n            }\n            catch (e_1_1) {\n                e_1 = { error: e_1_1 };\n            }\n            finally {\n                try {\n                    if (_c && !_c.done && (_a = _b.return))\n                        _a.call(_b);\n                }\n                finally {\n                    if (e_1)\n                        throw e_1.error;\n                }\n            }\n        };\n    return BsDropdownToggleDirective;\n}());\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\nvar DropdownModule = /*@__PURE__*/ (function () {\n    function DropdownModule() {\n    }\n    /**\n     * @param {?=} config\n     * @return {?}\n     */\n    DropdownModule.forRoot = /**\n     * @param {?=} config\n     * @return {?}\n     */\n        function (config) {\n            return {\n                ngModule: DropdownModule, providers: [\n                    ComponentLoaderFactory,\n                    PositioningService,\n                    BsDropdownState,\n                    { provide: BsDropdownConfig, useValue: config ? config : { autoClose: true } }\n                ]\n            };\n        };\n    return DropdownModule;\n}());\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\nvar MdbIconComponent = /*@__PURE__*/ (function () {\n    function MdbIconComponent(_el, _renderer) {\n        this._el = _el;\n        this._renderer = _renderer;\n        this.fab = false;\n        this.far = false;\n        this.fal = false;\n        this.fas = true;\n        this.sizeClass = '';\n    }\n    /**\n     * @return {?}\n     */\n    MdbIconComponent.prototype.ngOnInit = /**\n     * @return {?}\n     */\n        function () {\n            var _this = this;\n            if (this.size) {\n                this.sizeClass = \"fa-\" + this.size;\n            }\n            if (this._el.nativeElement.parentElement.classList.contains('md-form')) {\n                this._renderer.addClass(this._el.nativeElement, 'prefix');\n            }\n            /** @type {?} */\n            var classList = this._el.nativeElement.classList;\n            this.fab = classList.contains('fab');\n            this.far = classList.contains('far');\n            this.fas = classList.contains('fas');\n            this.fal = classList.contains('fal');\n            /** @type {?} */\n            var formWrapper = this._getClosestEl(this._el.nativeElement, '.md-form') ||\n                this._getClosestEl(this._el.nativeElement, '.md-outline');\n            if (formWrapper) {\n                formWrapper.childNodes.forEach((function (el) {\n                    if (el.tagName === 'INPUT') {\n                        _this._renderer.listen(el, 'focus', (function () {\n                            _this._renderer.addClass(_this._el.nativeElement, 'active');\n                        }));\n                        _this._renderer.listen(el, 'blur', (function () {\n                            _this._renderer.removeClass(_this._el.nativeElement, 'active');\n                        }));\n                    }\n                }));\n            }\n        };\n    /**\n     * @private\n     * @param {?} el\n     * @param {?} selector\n     * @return {?}\n     */\n    MdbIconComponent.prototype._getClosestEl = /**\n     * @private\n     * @param {?} el\n     * @param {?} selector\n     * @return {?}\n     */\n        function (el, selector) {\n            for (; el && el !== document$1; el = el.parentNode) {\n                if (el.matches && el.matches(selector)) {\n                    return el;\n                }\n            }\n            return null;\n        };\n    return MdbIconComponent;\n}());\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n// tslint:disable-next-line:directive-selector\nvar FalDirective = /*@__PURE__*/ (function () {\n    function FalDirective(_el, _r) {\n        this._el = _el;\n        this._r = _r;\n        this._r.addClass(this._el.nativeElement, 'fal');\n    }\n    return FalDirective;\n}());\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n// tslint:disable-next-line:directive-selector\nvar FarDirective = /*@__PURE__*/ (function () {\n    function FarDirective(_el, _r) {\n        this._el = _el;\n        this._r = _r;\n        this._r.addClass(this._el.nativeElement, 'far');\n    }\n    return FarDirective;\n}());\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n// tslint:disable-next-line:directive-selector\nvar FasDirective = /*@__PURE__*/ (function () {\n    function FasDirective(_el, _r) {\n        this._el = _el;\n        this._r = _r;\n        this._r.addClass(this._el.nativeElement, 'fas');\n    }\n    return FasDirective;\n}());\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n// tslint:disable-next-line:directive-selector\nvar FabDirective = /*@__PURE__*/ (function () {\n    function FabDirective(_el, _r) {\n        this._el = _el;\n        this._r = _r;\n        this._r.addClass(this._el.nativeElement, 'fab');\n    }\n    return FabDirective;\n}());\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\nvar IconsModule = /*@__PURE__*/ (function () {\n    function IconsModule() {\n    }\n    return IconsModule;\n}());\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/** @type {?} */\nvar defaultIdNumber$1 = 0;\nvar MdbErrorDirective = /*@__PURE__*/ (function () {\n    function MdbErrorDirective(el, renderer) {\n        this.el = el;\n        this.renderer = renderer;\n        this.id = \"mdb-error-\" + defaultIdNumber$1++;\n        this.errorMsg = true;\n        this.messageId = this.id;\n    }\n    /**\n     * @private\n     * @param {?} el\n     * @param {?} selector\n     * @return {?}\n     */\n    MdbErrorDirective.prototype._getClosestEl = /**\n     * @private\n     * @param {?} el\n     * @param {?} selector\n     * @return {?}\n     */\n        function (el, selector) {\n            for (; el && el !== document; el = el.previousElementSibling) {\n                if (el.matches(selector)) {\n                    return el;\n                }\n            }\n            return null;\n        };\n    /**\n     * @return {?}\n     */\n    MdbErrorDirective.prototype.ngOnInit = /**\n     * @return {?}\n     */\n        function () {\n            var _this = this;\n            /** @type {?} */\n            var textarea = this._getClosestEl(this.el.nativeElement, '.md-textarea');\n            if (textarea) {\n                /** @type {?} */\n                var height_1 = textarea.offsetHeight + 4 + 'px';\n                this.renderer.setStyle(this.el.nativeElement, 'top', height_1);\n                this.textareaListenFunction = this.renderer.listen(textarea, 'keyup', (function () {\n                    height_1 = textarea.offsetHeight + 4 + 'px';\n                    _this.renderer.setStyle(_this.el.nativeElement, 'top', height_1);\n                }));\n            }\n        };\n    /**\n     * @return {?}\n     */\n    MdbErrorDirective.prototype.ngOnDestroy = /**\n     * @return {?}\n     */\n        function () {\n            if (this.textareaListenFunction) {\n                this.textareaListenFunction();\n            }\n        };\n    return MdbErrorDirective;\n}());\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/** @type {?} */\nvar defaultIdNumber$2 = 0;\nvar MdbSuccessDirective = /*@__PURE__*/ (function () {\n    function MdbSuccessDirective(el, renderer) {\n        this.el = el;\n        this.renderer = renderer;\n        this.id = \"mdb-success-\" + defaultIdNumber$2++;\n        this.successMsg = true;\n        this.messageId = this.id;\n    }\n    /**\n     * @private\n     * @param {?} el\n     * @param {?} selector\n     * @return {?}\n     */\n    MdbSuccessDirective.prototype._getClosestEl = /**\n     * @private\n     * @param {?} el\n     * @param {?} selector\n     * @return {?}\n     */\n        function (el, selector) {\n            for (; el && el !== document; el = el.previousElementSibling) {\n                if (el.matches(selector)) {\n                    return el;\n                }\n            }\n            return null;\n        };\n    /**\n     * @return {?}\n     */\n    MdbSuccessDirective.prototype.ngOnInit = /**\n     * @return {?}\n     */\n        function () {\n            var _this = this;\n            /** @type {?} */\n            var textarea = this._getClosestEl(this.el.nativeElement, '.md-textarea');\n            if (textarea) {\n                /** @type {?} */\n                var height_1 = textarea.offsetHeight + 4 + 'px';\n                this.renderer.setStyle(this.el.nativeElement, 'top', height_1);\n                this.textareaListenFunction = this.renderer.listen(textarea, 'keyup', (function () {\n                    height_1 = textarea.offsetHeight + 4 + 'px';\n                    _this.renderer.setStyle(_this.el.nativeElement, 'top', height_1);\n                }));\n            }\n        };\n    /**\n     * @return {?}\n     */\n    MdbSuccessDirective.prototype.ngOnDestroy = /**\n     * @return {?}\n     */\n        function () {\n            if (this.textareaListenFunction) {\n                this.textareaListenFunction();\n            }\n        };\n    return MdbSuccessDirective;\n}());\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\nvar MdbValidateDirective = /*@__PURE__*/ (function () {\n    function MdbValidateDirective(renderer, el) {\n        this.renderer = renderer;\n        this.el = el;\n        this._validate = true;\n        this._validateSuccess = true;\n        this._validateError = true;\n    }\n    Object.defineProperty(MdbValidateDirective.prototype, \"validate\", {\n        get: /**\n         * @return {?}\n         */ function () {\n            return this._validate;\n        },\n        set: /**\n         * @param {?} value\n         * @return {?}\n         */ function (value) {\n            this._validate = value;\n            this.updateErrorClass();\n            this.updateSuccessClass();\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(MdbValidateDirective.prototype, \"validateSuccess\", {\n        get: /**\n         * @return {?}\n         */ function () {\n            return this._validateSuccess;\n        },\n        set: /**\n         * @param {?} value\n         * @return {?}\n         */ function (value) {\n            this._validateSuccess = value;\n            this.updateSuccessClass();\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(MdbValidateDirective.prototype, \"validateError\", {\n        get: /**\n         * @return {?}\n         */ function () {\n            return this._validateError;\n        },\n        set: /**\n         * @param {?} value\n         * @return {?}\n         */ function (value) {\n            this._validateError = value;\n            this.updateErrorClass();\n            this.updateSuccessClass();\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * @return {?}\n     */\n    MdbValidateDirective.prototype.updateSuccessClass = /**\n     * @return {?}\n     */\n        function () {\n            if (this.validate && this.validateSuccess) {\n                this.renderer.addClass(this.el.nativeElement, 'validate-success');\n            }\n            else {\n                this.renderer.removeClass(this.el.nativeElement, 'validate-success');\n            }\n        };\n    /**\n     * @return {?}\n     */\n    MdbValidateDirective.prototype.updateErrorClass = /**\n     * @return {?}\n     */\n        function () {\n            if (this.validate && this.validateError) {\n                this.renderer.addClass(this.el.nativeElement, 'validate-error');\n            }\n            else {\n                this.renderer.removeClass(this.el.nativeElement, 'validate-error');\n            }\n        };\n    /**\n     * @return {?}\n     */\n    MdbValidateDirective.prototype.ngOnInit = /**\n     * @return {?}\n     */\n        function () {\n            this.updateSuccessClass();\n            this.updateErrorClass();\n        };\n    return MdbValidateDirective;\n}());\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\nvar InputUtilitiesModule = /*@__PURE__*/ (function () {\n    function InputUtilitiesModule() {\n    }\n    return InputUtilitiesModule;\n}());\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\nvar EqualValidatorDirective = /*@__PURE__*/ (function () {\n    function EqualValidatorDirective(validateEqual, reverse) {\n        this.validateEqual = validateEqual;\n        this.reverse = reverse;\n    }\n    Object.defineProperty(EqualValidatorDirective.prototype, \"isReverse\", {\n        get: /**\n         * @private\n         * @return {?}\n         */ function () {\n            if (!this.reverse) {\n                return false;\n            }\n            return this.reverse === 'true' ? true : false;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * @param {?} c\n     * @return {?}\n     */\n    EqualValidatorDirective.prototype.validate = /**\n     * @param {?} c\n     * @return {?}\n     */\n        function (c) {\n            /** @type {?} */\n            var setToNullValue = null;\n            // self value (e.g. retype password)\n            /** @type {?} */\n            var v = c.value;\n            // control value (e.g. password)\n            // const e: any = c.root.get(this.validateEqual);\n            /** @type {?} */\n            var e = c.root.get(this.validateEqual);\n            // value not equal\n            if (e && v !== e.value) {\n                return { validateEqual: false };\n            }\n            // value equal and reverse\n            if (e && v === e.value && this.isReverse) {\n                delete e.errors['validateEqual'];\n                if (!Object.keys(e.errors).length) {\n                    e.setErrors(null);\n                }\n            }\n            // value not equal and reverse\n            if (e && v !== e.value && this.isReverse) {\n                e.setErrors({\n                    validateEqual: false\n                });\n            }\n            // return null;\n            return setToNullValue;\n        };\n    return EqualValidatorDirective;\n}());\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\nvar MdbInputDirective = /*@__PURE__*/ (function () {\n    function MdbInputDirective(_elRef, _renderer, platformId) {\n        this._elRef = _elRef;\n        this._renderer = _renderer;\n        this.el = null;\n        this.elLabel = null;\n        this.elIcon = null;\n        this.element = null;\n        this.mdbValidate = true;\n        this.validateSuccess = true;\n        this.validateError = true;\n        this.focusCheckbox = true;\n        this.focusRadio = true;\n        this.isBrowser = false;\n        this.isClicked = false;\n        this.el = _elRef;\n        this.isBrowser = isPlatformBrowser(platformId);\n    }\n    /**\n     * @return {?}\n     */\n    MdbInputDirective.prototype.onfocus = /**\n     * @return {?}\n     */\n        function () {\n            try {\n                this._renderer.addClass(this.elLabel, 'active');\n                this.isClicked = true;\n            }\n            catch (error) { }\n        };\n    /**\n     * @return {?}\n     */\n    MdbInputDirective.prototype.onblur = /**\n     * @return {?}\n     */\n        function () {\n            this.validationFunction();\n            try {\n                if (this.el.nativeElement.value === '') {\n                    this._renderer.removeClass(this.elLabel, 'active');\n                }\n                this.isClicked = false;\n            }\n            catch (error) { }\n        };\n    /**\n     * @return {?}\n     */\n    MdbInputDirective.prototype.onchange = /**\n     * @return {?}\n     */\n        function () {\n            try {\n                this.checkValue();\n            }\n            catch (error) { }\n        };\n    /**\n     * @return {?}\n     */\n    MdbInputDirective.prototype.oniput = /**\n     * @return {?}\n     */\n        function () {\n            this.validationFunction();\n        };\n    /**\n     * @param {?} event\n     * @return {?}\n     */\n    MdbInputDirective.prototype.onkeydown = /**\n     * @param {?} event\n     * @return {?}\n     */\n        function (event) {\n            try {\n                if (event.target.type === 'number') {\n                    if (event.shiftKey) {\n                        switch (event.keyCode) {\n                            case 38:\n                                event.target.value = +event.target.value + 10;\n                                break;\n                            case 40:\n                                event.target.value = +event.target.value - 10;\n                                break;\n                        }\n                    }\n                    if (event.altKey) {\n                        switch (event.keyCode) {\n                            case 38:\n                                event.target.value = +event.target.value + 0.1;\n                                break;\n                            case 40:\n                                event.target.value = +event.target.value - 0.1;\n                                break;\n                        }\n                    }\n                }\n            }\n            catch (error) { }\n            this.delayedResize();\n        };\n    /**\n     * @return {?}\n     */\n    MdbInputDirective.prototype.oncut = /**\n     * @return {?}\n     */\n        function () {\n            var _this = this;\n            try {\n                setTimeout((function () {\n                    _this.delayedResize();\n                }), 0);\n            }\n            catch (error) { }\n        };\n    /**\n     * @return {?}\n     */\n    MdbInputDirective.prototype.onpaste = /**\n     * @return {?}\n     */\n        function () {\n            var _this = this;\n            try {\n                setTimeout((function () {\n                    _this.delayedResize();\n                }), 0);\n            }\n            catch (error) { }\n        };\n    /**\n     * @return {?}\n     */\n    MdbInputDirective.prototype.ondrop = /**\n     * @return {?}\n     */\n        function () {\n            var _this = this;\n            try {\n                setTimeout((function () {\n                    _this.delayedResize();\n                }), 0);\n            }\n            catch (error) { }\n        };\n    /**\n     * @param {?} value\n     * @return {?}\n     */\n    MdbInputDirective.prototype.updateErrorMsg = /**\n     * @param {?} value\n     * @return {?}\n     */\n        function (value) {\n            if (this.wrongTextContainer) {\n                this.wrongTextContainer.innerHTML = value;\n            }\n        };\n    /**\n     * @param {?} value\n     * @return {?}\n     */\n    MdbInputDirective.prototype.updateSuccessMsg = /**\n     * @param {?} value\n     * @return {?}\n     */\n        function (value) {\n            if (this.rightTextContainer) {\n                this.rightTextContainer.innerHTML = value;\n            }\n        };\n    /**\n     * @return {?}\n     */\n    MdbInputDirective.prototype.ngOnInit = /**\n     * @return {?}\n     */\n        function () {\n            var _this = this;\n            try {\n                setTimeout((function () {\n                    _this.delayedResize();\n                }), 0);\n            }\n            catch (error) {\n                console.log(error);\n            }\n            // Inititalise a new <span> wrong/right elements and render it below the host component.\n            if (this.mdbValidate) {\n                this.wrongTextContainer = this._renderer.createElement('span');\n                this._renderer.addClass(this.wrongTextContainer, 'inputVal');\n                this._renderer.addClass(this.wrongTextContainer, 'text-danger');\n                this._renderer.appendChild(this._elRef.nativeElement.parentElement, this.wrongTextContainer);\n                /** @type {?} */\n                var textWrong = this._elRef.nativeElement.getAttribute('data-error');\n                this.wrongTextContainer.innerHTML = textWrong ? textWrong : 'wrong';\n                if (!textWrong && this.errorMessage !== undefined) {\n                    this.wrongTextContainer.innerHTML = this.errorMessage;\n                }\n                this._renderer.setStyle(this.wrongTextContainer, 'visibility', 'hidden');\n                this.rightTextContainer = this._renderer.createElement('span');\n                this._renderer.addClass(this.rightTextContainer, 'inputVal');\n                this._renderer.addClass(this.rightTextContainer, 'text-success');\n                this._renderer.appendChild(this._elRef.nativeElement.parentElement, this.rightTextContainer);\n                /** @type {?} */\n                var textSuccess = this._elRef.nativeElement.getAttribute('data-success');\n                this.rightTextContainer.innerHTML = textSuccess ? textSuccess : 'success';\n                if (!textSuccess && this.successMessage !== undefined) {\n                    this.rightTextContainer.innerHTML = this.successMessage;\n                }\n                this._renderer.setStyle(this.rightTextContainer, 'visibility', 'hidden');\n            }\n        };\n    /**\n     * @param {?} changes\n     * @return {?}\n     */\n    MdbInputDirective.prototype.ngOnChanges = /**\n     * @param {?} changes\n     * @return {?}\n     */\n        function (changes) {\n            if (changes.hasOwnProperty('errorMessage')) {\n                /** @type {?} */\n                var newErrorMsg = changes.errorMessage.currentValue;\n                this.updateErrorMsg(newErrorMsg);\n            }\n            if (changes.hasOwnProperty('successMessage')) {\n                /** @type {?} */\n                var newSuccessMsg = changes.successMessage.currentValue;\n                this.updateSuccessMsg(newSuccessMsg);\n            }\n        };\n    /**\n     * @return {?}\n     */\n    MdbInputDirective.prototype.ngDoCheck = /**\n     * @return {?}\n     */\n        function () {\n            if (this.mdbValidate &&\n                this._elRef.nativeElement.classList.contains('ng-valid') &&\n                this._elRef.nativeElement.classList.contains('ng-dirty') &&\n                !this._elRef.nativeElement.classList.contains('counter-success')) {\n                this._renderer.addClass(this._elRef.nativeElement, 'counter-success');\n                this._renderer.setStyle(this.wrongTextContainer, 'visibility', 'hidden');\n                this._renderer.setStyle(this.rightTextContainer, 'visibility', 'visible');\n                this._renderer.setStyle(this.rightTextContainer, 'top', this._elRef.nativeElement.offsetHeight + 'px');\n                this._renderer.setStyle(this.wrongTextContainer, 'top', this._elRef.nativeElement.offsetHeight + 'px');\n            }\n            if (this.mdbValidate &&\n                this._elRef.nativeElement.classList.contains('ng-invalid') &&\n                this._elRef.nativeElement.classList.contains('ng-dirty') &&\n                !this._elRef.nativeElement.classList.contains('counter-danger')) {\n                this._renderer.addClass(this._elRef.nativeElement, 'counter-danger');\n                this._renderer.setStyle(this.rightTextContainer, 'visibility', 'hidden');\n                this._renderer.setStyle(this.wrongTextContainer, 'visibility', 'visible');\n                this._renderer.setStyle(this.rightTextContainer, 'top', this._elRef.nativeElement.offsetHeight + 'px');\n                this._renderer.setStyle(this.wrongTextContainer, 'top', this._elRef.nativeElement.offsetHeight + 'px');\n            }\n            if ((this._elRef.nativeElement.classList.contains('ng-invalid') &&\n                this._elRef.nativeElement.classList.contains('ng-pristine') &&\n                this._elRef.nativeElement.classList.contains('ng-untouched')) ||\n                this._elRef.nativeElement.disabled) {\n                if (this._elRef.nativeElement.classList.contains('counter-success')) {\n                    this._renderer.removeClass(this._elRef.nativeElement, 'counter-success');\n                    this._renderer.setStyle(this.rightTextContainer, 'visibility', 'hidden');\n                }\n                else if (this._elRef.nativeElement.classList.contains('counter-danger')) {\n                    this._renderer.removeClass(this._elRef.nativeElement, 'counter-danger');\n                    this._renderer.setStyle(this.wrongTextContainer, 'visibility', 'hidden');\n                }\n            }\n            if (!this.validateSuccess) {\n                this._renderer.removeClass(this._elRef.nativeElement, 'counter-success');\n                this._renderer.setStyle(this.rightTextContainer, 'display', 'none');\n                if (this._elRef.nativeElement.classList.contains('ng-valid')) {\n                    this._renderer.removeClass(this._elRef.nativeElement, 'counter-danger');\n                }\n            }\n            if (!this.validateError) {\n                this._renderer.removeClass(this._elRef.nativeElement, 'counter-danger');\n                this._renderer.setStyle(this.wrongTextContainer, 'display', 'none');\n                if (this._elRef.nativeElement.classList.contains('ng-invalid')) {\n                    this._renderer.removeClass(this._elRef.nativeElement, 'counter-success');\n                }\n            }\n        };\n    /**\n     * @return {?}\n     */\n    MdbInputDirective.prototype.validationFunction = /**\n     * @return {?}\n     */\n        function () {\n            var _this = this;\n            setTimeout((function () {\n                if (_this._elRef.nativeElement.classList.contains('ng-invalid')) {\n                    _this._renderer.removeClass(_this._elRef.nativeElement, 'counter-success');\n                    _this._renderer.removeClass(_this._elRef.nativeElement, 'counter-danger');\n                }\n                if (_this._elRef.nativeElement.classList.contains('ng-touched') &&\n                    _this._elRef.nativeElement.classList.contains('ng-invalid')) {\n                    if (_this.mdbValidate) {\n                        _this._renderer.addClass(_this._elRef.nativeElement, 'counter-danger');\n                        _this._renderer.setStyle(_this.rightTextContainer, 'visibility', 'hidden');\n                        _this._renderer.setStyle(_this.wrongTextContainer, 'visibility', 'visible');\n                        _this._renderer.setStyle(_this.rightTextContainer, 'top', _this._elRef.nativeElement.offsetHeight + 'px');\n                        _this._renderer.setStyle(_this.wrongTextContainer, 'top', _this._elRef.nativeElement.offsetHeight + 'px');\n                    }\n                }\n                else if (_this._elRef.nativeElement.classList.contains('ng-touched') &&\n                    _this._elRef.nativeElement.classList.contains('ng-valid')) {\n                    if (_this.mdbValidate) {\n                        _this._renderer.addClass(_this._elRef.nativeElement, 'counter-success');\n                        _this._renderer.setStyle(_this.rightTextContainer, 'visibility', 'visible');\n                        _this._renderer.setStyle(_this.wrongTextContainer, 'visibility', 'hidden');\n                        _this._renderer.setStyle(_this.rightTextContainer, 'top', _this._elRef.nativeElement.offsetHeight + 'px');\n                        _this._renderer.setStyle(_this.wrongTextContainer, 'top', _this._elRef.nativeElement.offsetHeight + 'px');\n                    }\n                }\n            }), 0);\n        };\n    /**\n     * @return {?}\n     */\n    MdbInputDirective.prototype.ngAfterViewInit = /**\n     * @return {?}\n     */\n        function () {\n            if (this.isBrowser) {\n                try {\n                    this.element = document.querySelector('.md-textarea-auto');\n                }\n                catch (error) { }\n            }\n            /** @type {?} */\n            var type = this.el.nativeElement.type;\n            if (this.focusCheckbox && type === 'checkbox') {\n                this._renderer.addClass(this.el.nativeElement, 'onFocusSelect');\n            }\n            if (this.focusRadio && type === 'radio') {\n                this._renderer.addClass(this.el.nativeElement, 'onFocusSelect');\n            }\n        };\n    /**\n     * @return {?}\n     */\n    MdbInputDirective.prototype.ngAfterViewChecked = /**\n     * @return {?}\n     */\n        function () {\n            this.initComponent();\n            this.checkValue();\n            // tslint:disable-next-line:max-line-length\n            /* if (this.el.nativeElement.tagName === 'MDB-COMPLETER' && this.el.nativeElement.getAttribute('ng-reflect-model') == null && !this.isClicked) {\n                this._renderer.removeClass(this.elLabel, 'active');\n            } */\n        };\n    /**\n     * @return {?}\n     */\n    MdbInputDirective.prototype.resize = /**\n     * @return {?}\n     */\n        function () {\n            if (this.el.nativeElement.classList.contains('md-textarea-auto')) {\n                this._renderer.setStyle(this.el.nativeElement, 'height', 'auto');\n                this._renderer.setStyle(this.el.nativeElement, 'height', this.el.nativeElement.scrollHeight + 'px');\n            }\n        };\n    /**\n     * @return {?}\n     */\n    MdbInputDirective.prototype.delayedResize = /**\n     * @return {?}\n     */\n        function () {\n            var _this = this;\n            setTimeout((function () {\n                _this.resize();\n            }), 0);\n        };\n    /**\n     * @return {?}\n     */\n    MdbInputDirective.prototype.initComponent = /**\n     * @return {?}\n     */\n        function () {\n            /** @type {?} */\n            var inputId;\n            /** @type {?} */\n            var inputP;\n            if (this.isBrowser) {\n                try {\n                    inputId = this.el.nativeElement.id;\n                }\n                catch (err) { }\n                try {\n                    inputP = this.el.nativeElement.parentNode;\n                }\n                catch (err) { }\n                this.elLabel =\n                    inputP.querySelector('label[for=\"' + inputId + '\"]') || inputP.querySelector('label');\n                if (this.elLabel && this.el.nativeElement.value !== '') {\n                    this._renderer.addClass(this.elLabel, 'active');\n                }\n                this.elIcon = inputP.querySelector('i') || false;\n                if (this.elIcon) {\n                    this._renderer.addClass(this.elIcon, 'active');\n                }\n            }\n        };\n    /**\n     * @private\n     * @return {?}\n     */\n    MdbInputDirective.prototype.checkValue = /**\n     * @private\n     * @return {?}\n     */\n        function () {\n            /** @type {?} */\n            var value = '';\n            if (this.elLabel != null) {\n                value = this.el.nativeElement.value || '';\n                if (value === '') {\n                    this._renderer.removeClass(this.elLabel, 'active');\n                    if (this.elIcon) {\n                        this._renderer.removeClass(this.elIcon, 'active');\n                    }\n                    // tslint:disable-next-line:max-line-length\n                }\n                if ((value === '' && this.isClicked) ||\n                    (value === '' && this.el.nativeElement.placeholder) ||\n                    (value === '' && this.el.nativeElement.attributes.placeholder)) {\n                    this._renderer.addClass(this.elLabel, 'active');\n                }\n                if (this.el.nativeElement.getAttribute('ng-reflect-model') != null)\n                    ;\n            }\n        };\n    return MdbInputDirective;\n}());\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\nvar MdbInput = /*@__PURE__*/ (function () {\n    function MdbInput(el, _renderer, platformId) {\n        this.el = el;\n        this._renderer = _renderer;\n        this.elLabel = null;\n        this.elIcon = null;\n        this.element = null;\n        this.focusCheckbox = true;\n        this.focusRadio = true;\n        this.isBrowser = false;\n        this.isClicked = false;\n        this.isBrowser = isPlatformBrowser(platformId);\n    }\n    /**\n     * @return {?}\n     */\n    MdbInput.prototype.onfocus = /**\n     * @return {?}\n     */\n        function () {\n            try {\n                this._renderer.addClass(this.elLabel, 'active');\n                this.isClicked = true;\n            }\n            catch (error) { }\n        };\n    /**\n     * @return {?}\n     */\n    MdbInput.prototype.onblur = /**\n     * @return {?}\n     */\n        function () {\n            try {\n                if (this.el.nativeElement.value === '') {\n                    this._renderer.removeClass(this.elLabel, 'active');\n                }\n                this.isClicked = false;\n            }\n            catch (error) { }\n        };\n    /**\n     * @return {?}\n     */\n    MdbInput.prototype.onchange = /**\n     * @return {?}\n     */\n        function () {\n            try {\n                this.checkValue();\n            }\n            catch (error) { }\n        };\n    /**\n     * @return {?}\n     */\n    MdbInput.prototype.oniput = /**\n     * @return {?}\n     */\n        function () { };\n    /**\n     * @param {?} event\n     * @return {?}\n     */\n    MdbInput.prototype.onkeydown = /**\n     * @param {?} event\n     * @return {?}\n     */\n        function (event) {\n            try {\n                if (event.target.type === 'number') {\n                    if (event.shiftKey) {\n                        switch (event.keyCode) {\n                            case 38:\n                                event.target.value = +event.target.value + 10;\n                                break;\n                            case 40:\n                                event.target.value = +event.target.value - 10;\n                                break;\n                        }\n                    }\n                    if (event.altKey) {\n                        switch (event.keyCode) {\n                            case 38:\n                                event.target.value = +event.target.value + 0.1;\n                                break;\n                            case 40:\n                                event.target.value = +event.target.value - 0.1;\n                                break;\n                        }\n                    }\n                }\n            }\n            catch (error) { }\n            this.delayedResize();\n        };\n    /**\n     * @return {?}\n     */\n    MdbInput.prototype.oncut = /**\n     * @return {?}\n     */\n        function () {\n            var _this = this;\n            try {\n                setTimeout((function () {\n                    _this.delayedResize();\n                }), 0);\n            }\n            catch (error) { }\n        };\n    /**\n     * @return {?}\n     */\n    MdbInput.prototype.onpaste = /**\n     * @return {?}\n     */\n        function () {\n            var _this = this;\n            try {\n                setTimeout((function () {\n                    _this.delayedResize();\n                }), 0);\n            }\n            catch (error) { }\n        };\n    /**\n     * @return {?}\n     */\n    MdbInput.prototype.ondrop = /**\n     * @return {?}\n     */\n        function () {\n            var _this = this;\n            try {\n                setTimeout((function () {\n                    _this.delayedResize();\n                }), 0);\n            }\n            catch (error) { }\n        };\n    /**\n     * @return {?}\n     */\n    MdbInput.prototype.ngAfterViewInit = /**\n     * @return {?}\n     */\n        function () {\n            if (this.isBrowser) {\n                try {\n                    this.element = document.querySelector('.md-textarea-auto');\n                }\n                catch (error) { }\n            }\n            /** @type {?} */\n            var type = this.el.nativeElement.type;\n            if (this.focusCheckbox && type === 'checkbox') {\n                this._renderer.addClass(this.el.nativeElement, 'onFocusSelect');\n            }\n            if (this.focusRadio && type === 'radio') {\n                this._renderer.addClass(this.el.nativeElement, 'onFocusSelect');\n            }\n        };\n    /**\n     * @return {?}\n     */\n    MdbInput.prototype.ngAfterViewChecked = /**\n     * @return {?}\n     */\n        function () {\n            this.initComponent();\n            this.checkValue();\n        };\n    /**\n     * @return {?}\n     */\n    MdbInput.prototype.resize = /**\n     * @return {?}\n     */\n        function () {\n            if (this.el.nativeElement.classList.contains('md-textarea-auto')) {\n                this._renderer.setStyle(this.el.nativeElement, 'height', 'auto');\n                this._renderer.setStyle(this.el.nativeElement, 'height', this.el.nativeElement.scrollHeight + 'px');\n            }\n        };\n    /**\n     * @return {?}\n     */\n    MdbInput.prototype.delayedResize = /**\n     * @return {?}\n     */\n        function () {\n            var _this = this;\n            setTimeout((function () {\n                _this.resize();\n            }), 0);\n        };\n    /**\n     * @return {?}\n     */\n    MdbInput.prototype.initComponent = /**\n     * @return {?}\n     */\n        function () {\n            /** @type {?} */\n            var inputId;\n            /** @type {?} */\n            var inputP;\n            if (this.isBrowser) {\n                try {\n                    inputId = this.el.nativeElement.id;\n                }\n                catch (err) { }\n                try {\n                    inputP = this.el.nativeElement.parentNode;\n                }\n                catch (err) { }\n                this.elLabel =\n                    inputP.querySelector('label[for=\"' + inputId + '\"]') || inputP.querySelector('label');\n                if (this.elLabel && this.el.nativeElement.value !== '') {\n                    this._renderer.addClass(this.elLabel, 'active');\n                }\n                this.elIcon = inputP.querySelector('i') || false;\n                if (this.elIcon) {\n                    this._renderer.addClass(this.elIcon, 'active');\n                }\n            }\n        };\n    /**\n     * @private\n     * @return {?}\n     */\n    MdbInput.prototype.checkValue = /**\n     * @private\n     * @return {?}\n     */\n        function () {\n            /** @type {?} */\n            var value = '';\n            if (this.elLabel != null) {\n                value = this.el.nativeElement.value || '';\n                if (value === '') {\n                    this._renderer.removeClass(this.elLabel, 'active');\n                    if (this.elIcon) {\n                        this._renderer.removeClass(this.elIcon, 'active');\n                    }\n                }\n                if ((value === '' && this.isClicked) ||\n                    (value === '' && this.el.nativeElement.placeholder) ||\n                    (value === '' && this.el.nativeElement.attributes.placeholder)) {\n                    this._renderer.addClass(this.elLabel, 'active');\n                }\n            }\n        };\n    return MdbInput;\n}());\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\nvar InputsModule = /*@__PURE__*/ (function () {\n    function InputsModule() {\n    }\n    /**\n     * @return {?}\n     */\n    InputsModule.forRoot = /**\n     * @return {?}\n     */\n        function () {\n            return { ngModule: InputsModule, providers: [] };\n        };\n    return InputsModule;\n}());\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\nvar ModalOptions = /*@__PURE__*/ (function () {\n    function ModalOptions() {\n    }\n    return ModalOptions;\n}());\nvar MDBModalRef = /*@__PURE__*/ (function () {\n    function MDBModalRef() {\n    }\n    /**\n     * Hides the modal\n     */\n    /**\n     * Hides the modal\n     * @return {?}\n     */\n    MDBModalRef.prototype.hide = /**\n     * Hides the modal\n     * @return {?}\n     */\n        function () { };\n    return MDBModalRef;\n}());\nvar ɵ0 = {};\n/** @type {?} */\nvar modalConfigDefaults = {\n    backdrop: true,\n    keyboard: true,\n    focus: true,\n    show: false,\n    ignoreBackdropClick: false,\n    class: '',\n    containerClass: '',\n    animated: true,\n    scroll: false,\n    data: ɵ0\n};\n/** @type {?} */\nvar ClassName = {\n    SCROLLBAR_MEASURER: 'modal-scrollbar-measure',\n    BACKDROP: 'modal-backdrop',\n    OPEN: 'modal-open',\n    FADE: 'fade',\n    IN: 'in',\n    // bs3\n    SHOW: 'show' // bs4\n};\n/** @type {?} */\nvar TransitionDurations = {\n    MODAL: 300,\n    BACKDROP: 150\n};\n/** @type {?} */\nvar DISMISS_REASONS = {\n    BACKRDOP: 'backdrop-click',\n    ESC: 'esc'\n};\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\nvar Utils$1 = (function () {\n    function Utils() {\n    }\n    /**\n     * @param {?} element\n     * @return {?}\n     */\n    Utils.reflow = /**\n     * @param {?} element\n     * @return {?}\n     */\n        function (element) {\n            ((function (bs) { return bs; }))(element.offsetHeight);\n        };\n    // source: https://github.com/jquery/jquery/blob/master/src/css/var/getStyles.js\n    // source: https://github.com/jquery/jquery/blob/master/src/css/var/getStyles.js\n    /**\n     * @param {?} elem\n     * @return {?}\n     */\n    Utils.getStyles =\n        // source: https://github.com/jquery/jquery/blob/master/src/css/var/getStyles.js\n        /**\n         * @param {?} elem\n         * @return {?}\n         */\n        function (elem) {\n            // Support: IE <=11 only, Firefox <=30 (#15098, #14150)\n            // IE throws on elements created in popups\n            // FF meanwhile throws on frame elements through \"defaultView.getComputedStyle\"\n            /** @type {?} */\n            var view = elem.ownerDocument.defaultView;\n            if (!view || !view.opener) {\n                view = win;\n            }\n            return view.getComputedStyle(elem);\n        };\n    /**\n     * @param {?} event\n     * @param {?} el\n     * @return {?}\n     */\n    Utils.prototype.focusTrapModal = /**\n     * @param {?} event\n     * @param {?} el\n     * @return {?}\n     */\n        function (event, el) {\n            /** @type {?} */\n            var focusableElements;\n            /** @type {?} */\n            var firstFocusableElement;\n            /** @type {?} */\n            var lastFocusableElement;\n            /** @type {?} */\n            var KEYCODE_TAB = 9;\n            /*tslint:disable-next-line:max-line-length */\n            focusableElements = el.nativeElement.querySelectorAll('a[href], button, textarea, input, select, form, mdb-select, mdb-auto-completer, mdb-checkbox, mdb-range-input');\n            firstFocusableElement = focusableElements[0];\n            lastFocusableElement = focusableElements[focusableElements.length - 1];\n            if (event.key === 'Tab' || event.keyCode === KEYCODE_TAB) {\n                if (event.shiftKey) {\n                    if (document$1 && document$1.activeElement === firstFocusableElement) {\n                        lastFocusableElement.focus();\n                        event.preventDefault();\n                    }\n                }\n                else {\n                    if (document$1 && document$1.activeElement === lastFocusableElement) {\n                        firstFocusableElement.focus();\n                        event.preventDefault();\n                    }\n                }\n            }\n        };\n    /**\n     * @param {?} el\n     * @param {?} selector\n     * @return {?}\n     */\n    Utils.prototype.getClosestEl = /**\n     * @param {?} el\n     * @param {?} selector\n     * @return {?}\n     */\n        function (el, selector) {\n            for (; el && el !== document$1; el = el.parentNode) {\n                if (el.matches && el.matches(selector)) {\n                    return el;\n                }\n            }\n            return null;\n        };\n    /**\n     * @param {?} elem\n     * @return {?}\n     */\n    Utils.prototype.getCoords = /**\n     * @param {?} elem\n     * @return {?}\n     */\n        function (elem) {\n            /** @type {?} */\n            var box = elem.getBoundingClientRect();\n            /** @type {?} */\n            var body = document$1.body;\n            /** @type {?} */\n            var docEl = document$1.documentElement;\n            /** @type {?} */\n            var scrollTop = win.pageYOffset || docEl.scrollTop || body.scrollTop;\n            /** @type {?} */\n            var scrollLeft = win.pageXOffset || docEl.scrollLeft || body.scrollLeft;\n            /** @type {?} */\n            var clientTop = docEl.clientTop || body.clientTop || 0;\n            /** @type {?} */\n            var clientLeft = docEl.clientLeft || body.clientLeft || 0;\n            /** @type {?} */\n            var top = box.top + scrollTop - clientTop;\n            /** @type {?} */\n            var left = box.left + scrollLeft - clientLeft;\n            return { top: Math.round(top), left: Math.round(left) };\n        };\n    return Utils;\n}());\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\nvar ModalBackdropOptions = /*@__PURE__*/ (function () {\n    function ModalBackdropOptions(options) {\n        this.animate = true;\n        Object.assign(this, options);\n    }\n    return ModalBackdropOptions;\n}());\n/**\n * This component will be added as background layout for modals if enabled\n */\nvar ModalBackdropComponent = /*@__PURE__*/ (function () {\n    function ModalBackdropComponent(element, renderer) {\n        this.classNameBackDrop = true;\n        this._isShown = false;\n        this.element = element;\n        this.renderer = renderer;\n    }\n    Object.defineProperty(ModalBackdropComponent.prototype, \"isAnimated\", {\n        get: /**\n         * @return {?}\n         */ function () {\n            return this._isAnimated;\n        },\n        set: /**\n         * @param {?} value\n         * @return {?}\n         */ function (value) {\n            this._isAnimated = value;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(ModalBackdropComponent.prototype, \"isShown\", {\n        get: /**\n         * @return {?}\n         */ function () {\n            return this._isShown;\n        },\n        set: /**\n         * @param {?} value\n         * @return {?}\n         */ function (value) {\n            this._isShown = value;\n            if (value) {\n                this.renderer.addClass(this.element.nativeElement, \"\" + ClassName.IN);\n                if (!isBs3()) {\n                    this.renderer.addClass(this.element.nativeElement, \"\" + ClassName.SHOW);\n                }\n            }\n            else {\n                this.renderer.removeClass(this.element.nativeElement, \"\" + ClassName.IN);\n                if (!isBs3()) {\n                    this.renderer.removeClass(this.element.nativeElement, \"\" + ClassName.SHOW);\n                }\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * @return {?}\n     */\n    ModalBackdropComponent.prototype.ngOnInit = /**\n     * @return {?}\n     */\n        function () {\n            if (this.isAnimated) {\n                this.renderer.addClass(this.element.nativeElement, \"\" + ClassName.FADE);\n                Utils$1.reflow(this.element.nativeElement);\n            }\n            else {\n                this.renderer.addClass(this.element.nativeElement, \"\" + ClassName.FADE);\n                Utils$1.reflow(this.element.nativeElement);\n            }\n            this.isShown = true;\n        };\n    return ModalBackdropComponent;\n}());\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/** @type {?} */\nvar TRANSITION_DURATION = 300;\n/** @type {?} */\nvar BACKDROP_TRANSITION_DURATION = 150;\n/**\n * Mark any code with directive to show it's content in modal\n */\nvar ModalDirective = /*@__PURE__*/ (function () {\n    function ModalDirective(_element, _viewContainerRef, _renderer, clf) {\n        /**\n         * This event fires immediately when the `show` instance method is called.\n         */\n        // tslint:disable-next-line:no-output-on-prefix\n        this.onShow = new EventEmitter();\n        this.open = new EventEmitter();\n        /**\n         * This event is fired when the modal has been made visible to the user (will wait for CSS transitions to complete)\n         */\n        // tslint:disable-next-line:no-output-on-prefix\n        this.onShown = new EventEmitter();\n        this.opened = new EventEmitter();\n        /**\n         * This event is fired immediately when the hide instance method has been called.\n         */\n        // tslint:disable-next-line:no-output-on-prefix\n        this.onHide = new EventEmitter();\n        this.close = new EventEmitter();\n        /**\n         * This event is fired when the modal has finished being hidden from the user (will wait for CSS transitions to complete).\n         */\n        // tslint:disable-next-line:no-output-on-prefix\n        this.onHidden = new EventEmitter();\n        this.closed = new EventEmitter();\n        // seems like an Options\n        this.isAnimated = true;\n        this._isShown = false;\n        this.isBodyOverflowing = false;\n        this.originalBodyPadding = 0;\n        this.scrollbarWidth = 0;\n        this.timerHideModal = 0;\n        this.timerRmBackDrop = 0;\n        this.isNested = false;\n        this.utils = new Utils$1();\n        this._element = _element;\n        this._renderer = _renderer;\n        this._backdrop = clf.createLoader(_element, _viewContainerRef, _renderer);\n    }\n    Object.defineProperty(ModalDirective.prototype, \"config\", {\n        // public get config(): ModalOptions {\n        get: \n        // public get config(): ModalOptions {\n        /**\n         * @return {?}\n         */\n        function () {\n            return this._config;\n        },\n        /** allows to set modal configuration via element property */\n        set: /**\n         * allows to set modal configuration via element property\n         * @param {?} conf\n         * @return {?}\n         */ function (conf) {\n            this._config = this.getConfig(conf);\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(ModalDirective.prototype, \"isShown\", {\n        get: /**\n         * @return {?}\n         */ function () {\n            return this._isShown;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * @param {?} event\n     * @return {?}\n     */\n    ModalDirective.prototype.onKeyDown = /**\n     * @param {?} event\n     * @return {?}\n     */\n        function (event) {\n            this.utils.focusTrapModal(event, this._element);\n        };\n    /**\n     * @param {?} event\n     * @return {?}\n     */\n    ModalDirective.prototype.onClick = /**\n     * @param {?} event\n     * @return {?}\n     */\n        function (event) {\n            if (this.config.ignoreBackdropClick ||\n                this.config.backdrop === 'static' ||\n                event.target !== this._element.nativeElement) {\n                return;\n            }\n            this.dismissReason = DISMISS_REASONS.BACKRDOP;\n            this.hide(event);\n        };\n    // todo: consider preventing default and stopping propagation\n    // todo: consider preventing default and stopping propagation\n    /**\n     * @return {?}\n     */\n    ModalDirective.prototype.onEsc =\n        // todo: consider preventing default and stopping propagation\n        /**\n         * @return {?}\n         */\n        function () {\n            if (this.config.keyboard) {\n                this.dismissReason = DISMISS_REASONS.ESC;\n                this.hide();\n            }\n        };\n    /**\n     * @return {?}\n     */\n    ModalDirective.prototype.ngOnDestroy = /**\n     * @return {?}\n     */\n        function () {\n            this.config = void 0;\n            if (this._isShown) {\n                this._isShown = false;\n                this.hideModal();\n                this._backdrop.dispose();\n            }\n        };\n    /**\n     * @return {?}\n     */\n    ModalDirective.prototype.ngAfterViewInit = /**\n     * @return {?}\n     */\n        function () {\n            var _this = this;\n            this._config = this._config || this.getConfig();\n            setTimeout((function () {\n                if (_this._config.show) {\n                    _this.show();\n                }\n            }), 0);\n        };\n    /* Public methods */\n    /** Allows to manually toggle modal visibility */\n    /* Public methods */\n    /**\n     * Allows to manually toggle modal visibility\n     * @return {?}\n     */\n    ModalDirective.prototype.toggle = /* Public methods */\n        /**\n         * Allows to manually toggle modal visibility\n         * @return {?}\n         */\n        function () {\n            return this._isShown ? this.hide() : this.show();\n        };\n    /** Allows to manually open modal */\n    /**\n     * Allows to manually open modal\n     * @return {?}\n     */\n    ModalDirective.prototype.show = /**\n     * Allows to manually open modal\n     * @return {?}\n     */\n        function () {\n            var _this = this;\n            this.dismissReason = null;\n            this.onShow.emit(this);\n            this.open.emit(this);\n            if (this._isShown) {\n                return;\n            }\n            clearTimeout(this.timerHideModal);\n            clearTimeout(this.timerRmBackDrop);\n            this._isShown = true;\n            this.checkScrollbar();\n            this.setScrollbar();\n            if (document$1 && document$1.body) {\n                if (document$1.body.classList.contains(ClassName.OPEN)) {\n                    this.isNested = true;\n                }\n                else {\n                    this._renderer.addClass(document$1.body, ClassName.OPEN);\n                }\n            }\n            this.showBackdrop((function () {\n                _this.showElement();\n            }));\n            if (!this.config.backdrop && this.config.ignoreBackdropClick) {\n                /** @type {?} */\n                var style_1 = win.getComputedStyle(this._element.nativeElement.firstElementChild);\n                /** @type {?} */\n                var modalHeight = ['height', 'padding-top', 'padding-bottom', 'margin-top', 'margin-bottom']\n                    .map((function (key) { return parseInt(style_1.getPropertyValue(key), 10); }))\n                    .reduce((function (prev, cur) { return prev + cur; }));\n                this._renderer.setStyle(this._element.nativeElement, 'position', 'fixed');\n                this._renderer.setStyle(this._element.nativeElement, 'height', modalHeight + \"px\");\n                if (navigator$1.userAgent.indexOf('Safari') !== -1 &&\n                    navigator$1.userAgent.indexOf('Chrome') === -1) {\n                    this._renderer.setStyle(this._element.nativeElement, 'overflow', 'unset');\n                    this._renderer.setStyle(this._element.nativeElement, 'overflow-y', 'unset');\n                    this._renderer.setStyle(this._element.nativeElement, 'overflow-x', 'unset');\n                }\n            }\n        };\n    /** Allows to manually close modal */\n    /**\n     * Allows to manually close modal\n     * @param {?=} event\n     * @return {?}\n     */\n    ModalDirective.prototype.hide = /**\n     * Allows to manually close modal\n     * @param {?=} event\n     * @return {?}\n     */\n        function (event) {\n            var _this = this;\n            if (event) {\n                event.preventDefault();\n            }\n            // fix(modal): resolved problem with not pausing iframe/video when closing modal\n            /** @type {?} */\n            var iframeElements = Array.from(this._element.nativeElement.querySelectorAll('iframe'));\n            /** @type {?} */\n            var videoElements = Array.from(this._element.nativeElement.querySelectorAll('video'));\n            iframeElements.forEach((function (iframe) {\n                /** @type {?} */\n                var srcAttribute = iframe.getAttribute('src');\n                _this._renderer.setAttribute(iframe, 'src', srcAttribute);\n            }));\n            videoElements.forEach((function (video) {\n                video.pause();\n            }));\n            this.onHide.emit(this);\n            this.close.emit(this);\n            // todo: add an option to prevent hiding\n            if (!this._isShown) {\n                return;\n            }\n            clearTimeout(this.timerHideModal);\n            clearTimeout(this.timerRmBackDrop);\n            this._isShown = false;\n            this._renderer.removeClass(this._element.nativeElement, ClassName.IN);\n            if (!isBs3()) {\n                this._renderer.removeClass(this._element.nativeElement, ClassName.SHOW);\n            }\n            if (this.isAnimated) {\n                this.timerHideModal = setTimeout((function () { return _this.hideModal(); }), TRANSITION_DURATION);\n            }\n            else {\n                this.hideModal();\n            }\n        };\n    /** Private methods @internal */\n    /**\n     * Private methods \\@internal\n     * @protected\n     * @param {?=} config\n     * @return {?}\n     */\n    ModalDirective.prototype.getConfig = /**\n     * Private methods \\@internal\n     * @protected\n     * @param {?=} config\n     * @return {?}\n     */\n        function (config) {\n            return Object.assign({}, modalConfigDefaults, config);\n        };\n    /**\n     *  Show dialog\n     *  @internal\n     */\n    /**\n     *  Show dialog\n     * \\@internal\n     * @protected\n     * @return {?}\n     */\n    ModalDirective.prototype.showElement = /**\n     *  Show dialog\n     * \\@internal\n     * @protected\n     * @return {?}\n     */\n        function () {\n            var _this = this;\n            // todo: replace this with component loader usage\n            if (!this._element.nativeElement.parentNode ||\n                this._element.nativeElement.parentNode.nodeType !== Node.ELEMENT_NODE) {\n                // don't move modals dom position\n                if (document$1 && document$1.body) {\n                    document$1.body.appendChild(this._element.nativeElement);\n                }\n            }\n            this._renderer.setAttribute(this._element.nativeElement, 'aria-hidden', 'false');\n            this._renderer.setStyle(this._element.nativeElement, 'display', 'block');\n            this._renderer.setProperty(this._element.nativeElement, 'scrollTop', 0);\n            if (this.isAnimated) {\n                Utils$1.reflow(this._element.nativeElement);\n            }\n            this._renderer.addClass(this._element.nativeElement, ClassName.IN);\n            if (!isBs3()) {\n                this._renderer.addClass(this._element.nativeElement, ClassName.SHOW);\n            }\n            /** @type {?} */\n            var transitionComplete = (function () {\n                if (_this._config.focus) {\n                    _this._element.nativeElement.focus();\n                }\n                _this.onShown.emit(_this);\n                _this.opened.emit(_this);\n            });\n            if (this.isAnimated) {\n                setTimeout(transitionComplete, TRANSITION_DURATION);\n            }\n            else {\n                transitionComplete();\n            }\n        };\n    /** @internal */\n    /**\n     * \\@internal\n     * @protected\n     * @return {?}\n     */\n    ModalDirective.prototype.hideModal = /**\n     * \\@internal\n     * @protected\n     * @return {?}\n     */\n        function () {\n            var _this = this;\n            this._renderer.setAttribute(this._element.nativeElement, 'aria-hidden', 'true');\n            this._renderer.setStyle(this._element.nativeElement, 'display', 'none');\n            this.showBackdrop((function () {\n                if (!_this.isNested) {\n                    if (document$1 && document$1.body) {\n                        _this._renderer.removeClass(document$1.body, ClassName.OPEN);\n                    }\n                }\n                _this.resetAdjustments();\n                _this.focusOtherModal();\n                _this.onHidden.emit(_this);\n                _this.closed.emit(_this);\n            }));\n        };\n    // todo: original show was calling a callback when done, but we can use promise\n    /** @internal */\n    // todo: original show was calling a callback when done, but we can use promise\n    /**\n     * \\@internal\n     * @protected\n     * @param {?=} callback\n     * @return {?}\n     */\n    ModalDirective.prototype.showBackdrop =\n        // todo: original show was calling a callback when done, but we can use promise\n        /**\n         * \\@internal\n         * @protected\n         * @param {?=} callback\n         * @return {?}\n         */\n        function (callback) {\n            var _this = this;\n            if (this._isShown &&\n                this.config.backdrop &&\n                (!this.backdrop || !this.backdrop.instance.isShown)) {\n                this.removeBackdrop();\n                this._backdrop\n                    .attach(ModalBackdropComponent)\n                    .to('body')\n                    .show({ isAnimated: this.isAnimated });\n                this.backdrop = this._backdrop._componentRef;\n                if (!callback) {\n                    return;\n                }\n                if (!this.isAnimated) {\n                    callback();\n                    return;\n                }\n                setTimeout(callback, BACKDROP_TRANSITION_DURATION);\n            }\n            else if (!this._isShown && this.backdrop) {\n                this.backdrop.instance.isShown = false;\n                /** @type {?} */\n                var callbackRemove = (function () {\n                    _this.removeBackdrop();\n                    if (callback) {\n                        callback();\n                    }\n                });\n                if (this.backdrop.instance.isAnimated) {\n                    this.timerRmBackDrop = setTimeout(callbackRemove, BACKDROP_TRANSITION_DURATION);\n                }\n                else {\n                    callbackRemove();\n                }\n            }\n            else if (callback) {\n                callback();\n            }\n        };\n    /** @internal */\n    /**\n     * \\@internal\n     * @protected\n     * @return {?}\n     */\n    ModalDirective.prototype.removeBackdrop = /**\n     * \\@internal\n     * @protected\n     * @return {?}\n     */\n        function () {\n            this._backdrop.hide();\n        };\n    /**\n     * @protected\n     * @return {?}\n     */\n    ModalDirective.prototype.focusOtherModal = /**\n     * @protected\n     * @return {?}\n     */\n        function () {\n            try {\n                /** @type {?} */\n                var otherOpenedModals = this._element.nativeElement.parentElement.querySelectorAll('.in[mdbModal]');\n                if (!otherOpenedModals.length) {\n                    return;\n                }\n                //  this._renderer.invokeElementMethod(otherOpenedModals[otherOpenedModals.length - 1], 'focus');\n                otherOpenedModals[otherOpenedModals.length - 1].nativeElement.focus();\n            }\n            catch (error) { }\n        };\n    /** @internal */\n    /**\n     * \\@internal\n     * @protected\n     * @return {?}\n     */\n    ModalDirective.prototype.resetAdjustments = /**\n     * \\@internal\n     * @protected\n     * @return {?}\n     */\n        function () {\n            this._renderer.setStyle(this._element.nativeElement, 'paddingLeft', '');\n            this._renderer.setStyle(this._element.nativeElement, 'paddingRight', '');\n        };\n    /** Scroll bar tricks */\n    /** @internal */\n    /** Scroll bar tricks */\n    /**\n     * \\@internal\n     * @protected\n     * @return {?}\n     */\n    ModalDirective.prototype.checkScrollbar = /** Scroll bar tricks */\n        /**\n         * \\@internal\n         * @protected\n         * @return {?}\n         */\n        function () {\n            this.isBodyOverflowing = document$1.body.clientWidth < win.innerWidth;\n            this.scrollbarWidth = this.getScrollbarWidth();\n        };\n    /**\n     * @protected\n     * @return {?}\n     */\n    ModalDirective.prototype.setScrollbar = /**\n     * @protected\n     * @return {?}\n     */\n        function () {\n            if (!document$1) {\n                return;\n            }\n            this.originalBodyPadding = parseInt(win.getComputedStyle(document$1.body).getPropertyValue('padding-right') || 0, 10);\n        };\n    // thx d.walsh\n    // thx d.walsh\n    /**\n     * @protected\n     * @return {?}\n     */\n    ModalDirective.prototype.getScrollbarWidth =\n        // thx d.walsh\n        /**\n         * @protected\n         * @return {?}\n         */\n        function () {\n            /** @type {?} */\n            var scrollDiv = this._renderer.createElement('div', void 0);\n            this._renderer.appendChild(document$1.body, scrollDiv);\n            scrollDiv.className = ClassName.SCROLLBAR_MEASURER;\n            /** @type {?} */\n            var scrollbarWidth = scrollDiv.offsetWidth - scrollDiv.clientWidth;\n            document$1.body.removeChild(scrollDiv);\n            return scrollbarWidth;\n        };\n    return ModalDirective;\n}());\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/*tslint:disable:no-invalid-this */\n/**\n * @return {?}\n */\nfunction OnChange$1() {\n    /** @type {?} */\n    var sufix = 'Change';\n    return (function OnChangeHandler(target, propertyKey) {\n        /** @type {?} */\n        var _key = \" __\" + propertyKey + \"Value\";\n        Object.defineProperty(target, propertyKey, {\n            get: /**\n             * @return {?}\n             */ function () { return this[_key]; },\n            set: /**\n             * @param {?} value\n             * @return {?}\n             */ function (value) {\n                /** @type {?} */\n                var prevValue = this[_key];\n                this[_key] = value;\n                if (prevValue !== value && this[propertyKey + sufix]) {\n                    this[propertyKey + sufix].emit(value);\n                }\n            }\n        });\n    });\n}\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\nvar ModalContainerComponent = /*@__PURE__*/ (function () {\n    function ModalContainerComponent(options, _element, _renderer) {\n        // this.mdbModalService = msConfig.serviceInstance;\n        this._renderer = _renderer;\n        this.modalClass = 'modal';\n        this.tabindex = -1;\n        this.role = 'dialog';\n        this.modal = true;\n        this.isShown = false;\n        this.isModalHiding = false;\n        this.utils = new Utils$1();\n        this._element = _element;\n        this.config = Object.assign({}, options);\n    }\n    /**\n     * @param {?} event\n     * @return {?}\n     */\n    ModalContainerComponent.prototype.onClick = /**\n     * @param {?} event\n     * @return {?}\n     */\n        function (event) {\n            if (this.config.ignoreBackdropClick ||\n                this.config.backdrop === 'static' ||\n                event.target !== this._element.nativeElement) {\n                return;\n            }\n            this.mdbModalService.setDismissReason(DISMISS_REASONS.BACKRDOP);\n            this.hide();\n        };\n    /**\n     * @return {?}\n     */\n    ModalContainerComponent.prototype.onEsc = /**\n     * @return {?}\n     */\n        function () {\n            if (this.config.keyboard && this.level === this.mdbModalService.getModalsCount()) {\n                this.mdbModalService.setDismissReason(DISMISS_REASONS.ESC);\n                this.hide();\n            }\n        };\n    /**\n     * @param {?} event\n     * @return {?}\n     */\n    ModalContainerComponent.prototype.onKeyDown = /**\n     * @param {?} event\n     * @return {?}\n     */\n        function (event) {\n            this.utils.focusTrapModal(event, this._element);\n        };\n    /**\n     * @return {?}\n     */\n    ModalContainerComponent.prototype.ngOnInit = /**\n     * @return {?}\n     */\n        function () {\n            var _this = this;\n            if (this.config.animated) {\n                this._renderer.addClass(this._element.nativeElement, 'fade');\n            }\n            this._renderer.setStyle(this._element.nativeElement, 'display', 'block');\n            if ((window &&\n                window.navigator.userAgent.indexOf('Edge') !== -1 &&\n                this.config &&\n                this.config.toString().indexOf('side-modal') === -1) ||\n                (window &&\n                    window.navigator.userAgent.indexOf('Edge') !== -1 &&\n                    this.config &&\n                    this.config.toString().indexOf('modal-full-height') === -1)) {\n                this.isShown = true;\n                this._renderer.addClass(this._element.nativeElement, isBs3() ? ClassName.IN : ClassName.SHOW);\n                this._renderer.setStyle(this._element.nativeElement, 'transition', 'transform 0.3s ease-out');\n                this._renderer.setStyle(this._element.nativeElement, 'transform', 'translate(0, 25px)');\n            }\n            else {\n                setTimeout((function () {\n                    _this.isShown = true;\n                    _this._renderer.addClass(_this._element.nativeElement, isBs3() ? ClassName.IN : ClassName.SHOW);\n                }), this.isAnimated ? TransitionDurations.BACKDROP : 0);\n            }\n            if (document && document.body) {\n                if (this.mdbModalService.getModalsCount() === 1) {\n                    this.mdbModalService.checkScrollbar();\n                    this.mdbModalService.setScrollbar();\n                }\n                this._renderer.addClass(document.body, ClassName.OPEN);\n            }\n            if (this.config.containerClass) {\n                this.updateContainerClass();\n            }\n            if (this.config.scroll) {\n                this._renderer.setStyle(this._element.nativeElement, 'overflow-y', 'auto');\n            }\n        };\n    /**\n     * @return {?}\n     */\n    ModalContainerComponent.prototype.focusModalElement = /**\n     * @return {?}\n     */\n        function () {\n            if (this.config.focus) {\n                this._element.nativeElement.focus();\n            }\n        };\n    /**\n     * @return {?}\n     */\n    ModalContainerComponent.prototype.updateContainerClass = /**\n     * @return {?}\n     */\n        function () {\n            if (this.config.containerClass) {\n                /** @type {?} */\n                var containerClasses = this.config.containerClass;\n                /** @type {?} */\n                var classArr = containerClasses.split(' ');\n                for (var i = 0; i < classArr.length; i++) {\n                    this._renderer.addClass(this._element.nativeElement, classArr[i]);\n                }\n            }\n        };\n    /**\n     * @return {?}\n     */\n    ModalContainerComponent.prototype.ngOnDestroy = /**\n     * @return {?}\n     */\n        function () {\n            if (this.isShown) {\n                this.hide();\n            }\n        };\n    /**\n     * @return {?}\n     */\n    ModalContainerComponent.prototype.hide = /**\n     * @return {?}\n     */\n        function () {\n            var _this = this;\n            if (this.isModalHiding || !this.isShown) {\n                return;\n            }\n            this.isModalHiding = true;\n            this._renderer.removeClass(this._element.nativeElement, isBs3() ? ClassName.IN : ClassName.SHOW);\n            // fix(modal): resolved problem with not pausing iframe/video when closing modal\n            /** @type {?} */\n            var iframeElements = Array.from(this._element.nativeElement.querySelectorAll('iframe'));\n            /** @type {?} */\n            var videoElements = Array.from(this._element.nativeElement.querySelectorAll('video'));\n            iframeElements.forEach((function (iframe) {\n                /** @type {?} */\n                var srcAttribute = iframe.getAttribute('src');\n                _this._renderer.setAttribute(iframe, 'src', srcAttribute);\n            }));\n            videoElements.forEach((function (video) {\n                video.pause();\n            }));\n            setTimeout((function () {\n                _this.isShown = false;\n                if (document && document.body && _this.mdbModalService.getModalsCount() === 1) {\n                    _this._renderer.removeClass(document.body, ClassName.OPEN);\n                }\n                _this.mdbModalService.hide(_this.level);\n                _this.isModalHiding = false;\n            }), this.isAnimated ? TransitionDurations.MODAL : 0);\n        };\n    return ModalContainerComponent;\n}());\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\nvar MDBModalService = /*@__PURE__*/ (function () {\n    // public constructor(private clf: ComponentLoaderFactory) {\n    function MDBModalService(rendererFactory, clf) {\n        this.clf = clf;\n        // constructor props\n        this.config = modalConfigDefaults;\n        this.open = new EventEmitter();\n        this.opened = new EventEmitter();\n        this.close = new EventEmitter();\n        this.closed = new EventEmitter();\n        this.isBodyOverflowing = false;\n        this.originalBodyPadding = 0;\n        this.scrollbarWidth = 0;\n        this.modalsCount = 0;\n        // private lastDismissReason = '';\n        this.lastDismissReason = '';\n        this.loaders = [];\n        //   this._backdropLoader = this.clf.createLoader<ModalBackdropComponent>(null, null, null);\n        this._backdropLoader = this.clf.createLoader(this.el, this.vcr, this.renderer);\n        this.renderer = rendererFactory.createRenderer(null, null);\n    }\n    /** Shows a modal */\n    /**\n     * Shows a modal\n     * @param {?} content\n     * @param {?=} config\n     * @return {?}\n     */\n    MDBModalService.prototype.show = /**\n     * Shows a modal\n     * @param {?} content\n     * @param {?=} config\n     * @return {?}\n     */\n        function (content, config) {\n            this.modalsCount++;\n            this._createLoaders();\n            this.config = Object.assign({}, modalConfigDefaults, config);\n            this._showBackdrop();\n            this.lastDismissReason = null;\n            return this._showModal(content);\n        };\n    /**\n     * @param {?} level\n     * @return {?}\n     */\n    MDBModalService.prototype.hide = /**\n     * @param {?} level\n     * @return {?}\n     */\n        function (level) {\n            var _this = this;\n            if (this.modalsCount === 1) {\n                this._hideBackdrop();\n                this.resetScrollbar();\n            }\n            this.modalsCount = this.modalsCount >= 1 ? this.modalsCount - 1 : 0;\n            setTimeout((function () {\n                _this._hideModal(level);\n                _this.removeLoaders(level);\n            }), this.config.animated ? TransitionDurations.BACKDROP : 0);\n        };\n    /**\n     * @return {?}\n     */\n    MDBModalService.prototype._showBackdrop = /**\n     * @return {?}\n     */\n        function () {\n            /** @type {?} */\n            var isBackdropEnabled = this.config.backdrop || this.config.backdrop === 'static';\n            /** @type {?} */\n            var isBackdropInDOM = !this.backdropRef || !this.backdropRef.instance.isShown;\n            if (this.modalsCount === 1) {\n                this.removeBackdrop();\n                if (isBackdropEnabled && isBackdropInDOM) {\n                    this._backdropLoader\n                        .attach(ModalBackdropComponent)\n                        .to('body')\n                        .show({ isAnimated: this.config.animated });\n                    this.backdropRef = this._backdropLoader._componentRef;\n                }\n            }\n        };\n    /**\n     * @return {?}\n     */\n    MDBModalService.prototype._hideBackdrop = /**\n     * @return {?}\n     */\n        function () {\n            var _this = this;\n            if (!this.backdropRef) {\n                return;\n            }\n            this.backdropRef.instance.isShown = false;\n            /** @type {?} */\n            var duration = this.config.animated ? TransitionDurations.BACKDROP : 0;\n            setTimeout((function () { return _this.removeBackdrop(); }), duration);\n        };\n    /**\n     * @param {?} content\n     * @return {?}\n     */\n    MDBModalService.prototype._showModal = /**\n     * @param {?} content\n     * @return {?}\n     */\n        function (content) {\n            /** @type {?} */\n            var modalLoader = this.loaders[this.loaders.length - 1];\n            /** @type {?} */\n            var mdbModalRef = new MDBModalRef();\n            /** @type {?} */\n            var modalContainerRef = modalLoader\n                .provide({ provide: ModalOptions, useValue: this.config })\n                .provide({ provide: MDBModalRef, useValue: mdbModalRef })\n                .attach(ModalContainerComponent)\n                .to('body')\n                .show({\n                content: content,\n                isAnimated: this.config.animated,\n                data: this.config.data,\n                mdbModalService: this,\n            });\n            modalContainerRef.instance.focusModalElement();\n            modalContainerRef.instance.level = this.getModalsCount();\n            mdbModalRef.hide = (function () {\n                modalContainerRef.instance.hide();\n            });\n            mdbModalRef.content = modalLoader.getInnerComponent() || null;\n            return mdbModalRef;\n        };\n    /**\n     * @param {?} level\n     * @return {?}\n     */\n    MDBModalService.prototype._hideModal = /**\n     * @param {?} level\n     * @return {?}\n     */\n        function (level) {\n            /** @type {?} */\n            var modalLoader = this.loaders[level - 1];\n            if (modalLoader) {\n                modalLoader.hide();\n            }\n        };\n    /**\n     * @return {?}\n     */\n    MDBModalService.prototype.getModalsCount = /**\n     * @return {?}\n     */\n        function () {\n            return this.modalsCount;\n        };\n    /**\n     * @param {?} reason\n     * @return {?}\n     */\n    MDBModalService.prototype.setDismissReason = /**\n     * @param {?} reason\n     * @return {?}\n     */\n        function (reason) {\n            this.lastDismissReason = reason;\n        };\n    /**\n     * @protected\n     * @return {?}\n     */\n    MDBModalService.prototype.removeBackdrop = /**\n     * @protected\n     * @return {?}\n     */\n        function () {\n            this._backdropLoader.hide();\n            this.backdropRef = null;\n        };\n    /** AFTER PR MERGE MODAL.COMPONENT WILL BE USING THIS CODE*/\n    /** Scroll bar tricks */\n    /** @internal */\n    /** AFTER PR MERGE MODAL.COMPONENT WILL BE USING THIS CODE*/\n    /** Scroll bar tricks */\n    /**\n     * \\@internal\n     * @return {?}\n     */\n    MDBModalService.prototype.checkScrollbar = /** AFTER PR MERGE MODAL.COMPONENT WILL BE USING THIS CODE*/\n        /** Scroll bar tricks */\n        /**\n         * \\@internal\n         * @return {?}\n         */\n        function () {\n            this.isBodyOverflowing = document.body.clientWidth < window.innerWidth;\n            this.scrollbarWidth = this.getScrollbarWidth();\n        };\n    /**\n     * @return {?}\n     */\n    MDBModalService.prototype.setScrollbar = /**\n     * @return {?}\n     */\n        function () {\n            if (!document) {\n                return;\n            }\n            this.originalBodyPadding = parseInt(window.getComputedStyle(document.body).getPropertyValue('padding-right') || '0', 10);\n        };\n    /**\n     * @private\n     * @return {?}\n     */\n    MDBModalService.prototype.resetScrollbar = /**\n     * @private\n     * @return {?}\n     */\n        function () {\n            document.body.style.paddingRight = this.originalBodyPadding + 'px';\n        };\n    // thx d.walsh\n    // thx d.walsh\n    /**\n     * @private\n     * @return {?}\n     */\n    MDBModalService.prototype.getScrollbarWidth =\n        // thx d.walsh\n        /**\n         * @private\n         * @return {?}\n         */\n        function () {\n            /** @type {?} */\n            var scrollDiv = this.renderer.createElement('div');\n            this.renderer.addClass(scrollDiv, ClassName.SCROLLBAR_MEASURER);\n            this.renderer.appendChild(document.body, scrollDiv);\n            /** @type {?} */\n            var scrollbarWidth = scrollDiv.offsetWidth - scrollDiv.clientWidth;\n            this.renderer.removeChild(document.body, scrollDiv);\n            return scrollbarWidth;\n        };\n    /**\n     * @private\n     * @return {?}\n     */\n    MDBModalService.prototype._createLoaders = /**\n     * @private\n     * @return {?}\n     */\n        function () {\n            // const loader = this.clf.createLoader<ModalContainerComponent>(null, null, null);\n            /** @type {?} */\n            var loader = this.clf.createLoader(this.el, this.vcr, this.renderer);\n            this.copyEvent(loader.onBeforeShow, this.open);\n            this.copyEvent(loader.onShown, this.opened);\n            this.copyEvent(loader.onBeforeHide, this.close);\n            this.copyEvent(loader.onHidden, this.closed);\n            this.loaders.push(loader);\n        };\n    /**\n     * @private\n     * @param {?} level\n     * @return {?}\n     */\n    MDBModalService.prototype.removeLoaders = /**\n     * @private\n     * @param {?} level\n     * @return {?}\n     */\n        function (level) {\n            this.loaders.splice(level - 1, 1);\n            this.loaders.forEach((function (loader, i) {\n                loader.instance.level = i + 1;\n            }));\n        };\n    /**\n     * @private\n     * @param {?} from\n     * @param {?} to\n     * @return {?}\n     */\n    MDBModalService.prototype.copyEvent = /**\n     * @private\n     * @param {?} from\n     * @param {?} to\n     * @return {?}\n     */\n        function (from, to) {\n            var _this = this;\n            from.subscribe((function () {\n                to.emit(_this.lastDismissReason);\n            }));\n        };\n    return MDBModalService;\n}());\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\nvar ModalModule = /*@__PURE__*/ (function () {\n    function ModalModule() {\n    }\n    /**\n     * @return {?}\n     */\n    ModalModule.forRoot = /**\n     * @return {?}\n     */\n        function () {\n            return { ngModule: ModalModule, providers: [MDBModalService, ComponentLoaderFactory, PositioningService] };\n        };\n    return ModalModule;\n}());\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\nvar NavbarService = /*@__PURE__*/ (function () {\n    function NavbarService() {\n        this.navbarLinkClicks = new Subject();\n    }\n    /**\n     * @return {?}\n     */\n    NavbarService.prototype.getNavbarLinkClicks = /**\n     * @return {?}\n     */\n        function () {\n            return this.navbarLinkClicks.asObservable();\n        };\n    /**\n     * @return {?}\n     */\n    NavbarService.prototype.setNavbarLinkClicks = /**\n     * @return {?}\n     */\n        function () {\n            this.navbarLinkClicks.next();\n        };\n    return NavbarService;\n}());\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\nvar LinksComponent = /*@__PURE__*/ (function () {\n    function LinksComponent(_navbarService) {\n        this._navbarService = _navbarService;\n        this.linkClick = new EventEmitter();\n    }\n    /**\n     * @return {?}\n     */\n    LinksComponent.prototype.ngAfterContentInit = /**\n     * @return {?}\n     */\n        function () {\n            /** @type {?} */\n            var that = this;\n            setTimeout((function () {\n                that.links.forEach((function (element) {\n                    element.nativeElement.onclick = (function () {\n                        that._navbarService.setNavbarLinkClicks();\n                    });\n                }));\n            }), 0);\n        };\n    return LinksComponent;\n}());\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\nvar NavbarComponent = /*@__PURE__*/ (function () {\n    function NavbarComponent(renderer, _navbarService) {\n        var _this = this;\n        this.renderer = renderer;\n        this._navbarService = _navbarService;\n        this.containerInside = true;\n        this.collapseId = 'navbarCollapse';\n        this.scrollSensitivity = 120;\n        this.scrollableNavbar = false;\n        this.shown = false;\n        this.duration = 350; // ms\n        // ms\n        this.collapse = true;\n        this.showClass = false;\n        this.collapsing = false;\n        this._itemsLength = 0;\n        this.ariaExpanded = false;\n        // tslint:disable-next-line:max-line-length\n        this.subscription = this._navbarService.getNavbarLinkClicks().subscribe((function (navbarLinkClicks) {\n            _this.closeNavbarOnClick(navbarLinkClicks);\n        }));\n    }\n    /**\n     * @param {?} navbarLinkClicks\n     * @return {?}\n     */\n    NavbarComponent.prototype.closeNavbarOnClick = /**\n     * @param {?} navbarLinkClicks\n     * @return {?}\n     */\n        function (navbarLinkClicks) {\n            this.navbarLinkClicks = navbarLinkClicks;\n            if (this.showClass) {\n                this.hide();\n            }\n        };\n    /**\n     * @return {?}\n     */\n    NavbarComponent.prototype.addTogglerIconClasses = /**\n     * @return {?}\n     */\n        function () {\n            var _this = this;\n            if (this.iconBackground) {\n                if (Array.isArray(this.iconBackground)) {\n                    this.iconBackground.forEach((function (iconClass) {\n                        _this.renderer.addClass(_this.toggler.nativeElement, iconClass);\n                    }));\n                }\n                else {\n                    this.renderer.addClass(this.toggler.nativeElement, this.iconBackground);\n                }\n            }\n        };\n    /**\n     * @return {?}\n     */\n    NavbarComponent.prototype.ngOnInit = /**\n     * @return {?}\n     */\n        function () {\n            /** @type {?} */\n            var isDoubleNav = this.SideClass.split(' ');\n            if (isDoubleNav.indexOf('double-nav') !== -1) {\n                this.doubleNav = true;\n            }\n            else {\n                this.doubleNav = false;\n            }\n        };\n    /**\n     * @return {?}\n     */\n    NavbarComponent.prototype.ngAfterViewInit = /**\n     * @return {?}\n     */\n        function () {\n            var _this = this;\n            if (!this.containerInside) {\n                /** @type {?} */\n                var childrens = Array.from(this.container.nativeElement.children);\n                childrens.forEach((function (child) {\n                    _this.renderer.appendChild(_this.navbar.nativeElement, child);\n                    _this.container.nativeElement.remove();\n                }));\n            }\n            if (this.el.nativeElement.children.length === 0) {\n                this.el.nativeElement.remove();\n            }\n            this.addTogglerIconClasses();\n            if (this.scrollableNavbar) {\n                this.renderer.addClass(this.el.nativeElement, 'collapsed-navbar-scroll');\n            }\n        };\n    /**\n     * @return {?}\n     */\n    NavbarComponent.prototype.toggle = /**\n     * @return {?}\n     */\n        function () {\n            if (!this.collapsing) {\n                if (this.shown) {\n                    this.hide();\n                }\n                else {\n                    this.show();\n                }\n            }\n        };\n    /**\n     * @return {?}\n     */\n    NavbarComponent.prototype.show = /**\n     * @return {?}\n     */\n        function () {\n            var _this = this;\n            this.shown = true;\n            this.collapse = false;\n            this.collapsing = true;\n            this.ariaExpanded = true;\n            setTimeout((function () {\n                _this.height = _this.el.nativeElement.scrollHeight;\n                _this.renderer.setStyle(_this.el.nativeElement, 'height', _this.height + 'px');\n            }), 0);\n            setTimeout((function () {\n                _this.collapsing = false;\n                _this.collapse = true;\n                _this.showClass = true;\n            }), this.duration);\n        };\n    /**\n     * @return {?}\n     */\n    NavbarComponent.prototype.hide = /**\n     * @return {?}\n     */\n        function () {\n            var _this = this;\n            if (this.shown) {\n                this.shown = false;\n                this.collapse = false;\n                this.showClass = false;\n                this.collapsing = true;\n                this.ariaExpanded = false;\n                setTimeout((function () {\n                    _this.renderer.setStyle(_this.el.nativeElement, 'height', '0px');\n                }), 0);\n                setTimeout((function () {\n                    _this.collapsing = false;\n                    _this.collapse = true;\n                }), this.duration);\n            }\n        };\n    Object.defineProperty(NavbarComponent.prototype, \"displayStyle\", {\n        get: /**\n         * @return {?}\n         */ function () {\n            if (!this.containerInside) {\n                return 'flex';\n            }\n            else {\n                return '';\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * @param {?} event\n     * @return {?}\n     */\n    NavbarComponent.prototype.onResize = /**\n     * @param {?} event\n     * @return {?}\n     */\n        function (event) {\n            var _this = this;\n            /** @type {?} */\n            var breakpoit = 0;\n            if (this.SideClass.includes('navbar-expand-xl')) {\n                breakpoit = 1200;\n            }\n            else if (this.SideClass.includes('navbar-expand-lg')) {\n                breakpoit = 992;\n            }\n            else if (this.SideClass.includes('navbar-expand-md')) {\n                breakpoit = 768;\n            }\n            else if (this.SideClass.includes('navbar-expand-sm')) {\n                breakpoit = 576;\n            }\n            else {\n                breakpoit = event.target.innerWidth + 1;\n            }\n            if (event.target.innerWidth < breakpoit) {\n                if (!this.shown) {\n                    this.collapse = false;\n                    this.renderer.setStyle(this.el.nativeElement, 'height', '0px');\n                    this.renderer.setStyle(this.el.nativeElement, 'opacity', '0');\n                    setTimeout((function () {\n                        _this.height = _this.el.nativeElement.scrollHeight;\n                        _this.collapse = true;\n                        _this.renderer.setStyle(_this.el.nativeElement, 'opacity', '');\n                    }), 4);\n                }\n            }\n            else {\n                this.collapsing = false;\n                this.shown = false;\n                this.showClass = false;\n                this.collapse = true;\n                this.ariaExpanded = false;\n                this.renderer.setStyle(this.el.nativeElement, 'height', '');\n            }\n        };\n    /**\n     * @return {?}\n     */\n    NavbarComponent.prototype.onScroll = /**\n     * @return {?}\n     */\n        function () {\n            if (this.navbar.nativeElement.classList.contains('scrolling-navbar')) {\n                if (window.pageYOffset > this.scrollSensitivity) {\n                    this.renderer.addClass(this.navbar.nativeElement, 'top-nav-collapse');\n                }\n                else {\n                    this.renderer.removeClass(this.navbar.nativeElement, 'top-nav-collapse');\n                }\n            }\n        };\n    /**\n     * @return {?}\n     */\n    NavbarComponent.prototype.ngAfterContentChecked = /**\n     * @return {?}\n     */\n        function () {\n            if (this.el.nativeElement.firstElementChild) {\n                if (this._itemsLength !==\n                    this.el.nativeElement.firstElementChild.firstElementChild.children.length) {\n                    this.height = this.el.nativeElement.firstElementChild.firstElementChild.clientHeight;\n                    this.renderer.setStyle(this.el.nativeElement, 'height', this.height + 'px');\n                }\n                this._itemsLength = this.el.nativeElement.firstElementChild.firstElementChild.children.length;\n            }\n        };\n    return NavbarComponent;\n}());\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\nvar LogoComponent = /*@__PURE__*/ (function () {\n    function LogoComponent() {\n    }\n    return LogoComponent;\n}());\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\nvar NavlinksComponent = /*@__PURE__*/ (function () {\n    function NavlinksComponent(_navbarService) {\n        this._navbarService = _navbarService;\n        this.linkClick = new EventEmitter();\n    }\n    /**\n     * @return {?}\n     */\n    NavlinksComponent.prototype.ngAfterContentInit = /**\n     * @return {?}\n     */\n        function () {\n            /** @type {?} */\n            var that = this;\n            setTimeout((function () {\n                that.links.forEach((function (element) {\n                    element.nativeElement.onclick = (function () {\n                        that._navbarService.setNavbarLinkClicks();\n                    });\n                }));\n            }), 0);\n        };\n    return NavlinksComponent;\n}());\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\nvar NavbarModule = /*@__PURE__*/ (function () {\n    function NavbarModule() {\n    }\n    return NavbarModule;\n}());\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * Configuration service for the Popover directive.\n * You can inject this service, typically in your root component, and customize\n * the values of its properties in order to provide default values for all the\n * popovers used in the application.\n */\nvar PopoverConfig = /*@__PURE__*/ (function () {\n    function PopoverConfig() {\n        /**\n         * Placement of a popover. Accepts: \"top\", \"bottom\", \"left\", \"right\"\n         */\n        this.placement = 'top';\n        /**\n         * Specifies events that should trigger. Supports a space separated list of\n         * event names.\n         */\n        this.triggers = 'click';\n    }\n    return PopoverConfig;\n}());\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\nvar PopoverContainerComponent = /*@__PURE__*/ (function () {\n    function PopoverContainerComponent(config) {\n        this.show = '!isBs3';\n        this.role = 'tooltip';\n        Object.assign(this, config);\n    }\n    Object.defineProperty(PopoverContainerComponent.prototype, \"isBs3\", {\n        get: /**\n         * @return {?}\n         */ function () {\n            return isBs3();\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * @return {?}\n     */\n    PopoverContainerComponent.prototype.ngOnInit = /**\n     * @return {?}\n     */\n        function () {\n            this.class =\n                'popover-fadeIn popover in popover-' +\n                    this.placement +\n                    ' ' +\n                    this.placement +\n                    ' bs-popover-' +\n                    this.placement;\n        };\n    return PopoverContainerComponent;\n}());\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * A lightweight, extensible directive for fancy popover creation.\n */\nvar PopoverDirective = /*@__PURE__*/ (function () {\n    function PopoverDirective(_elementRef, _renderer, _viewContainerRef, _config, cis, _positionService) {\n        this._positionService = _positionService;\n        this.dynamicPosition = true;\n        this.outsideClick = false;\n        this._popover = cis\n            .createLoader(_elementRef, _viewContainerRef, _renderer)\n            .provide({ provide: PopoverConfig, useValue: _config });\n        Object.assign(this, _config);\n        this.onShown = this._popover.onShown;\n        this.shown = this._popover.onShown;\n        this.onHidden = this._popover.onHidden;\n        this.hidden = this._popover.onHidden;\n    }\n    Object.defineProperty(PopoverDirective.prototype, \"isOpen\", {\n        /**\n         * Returns whether or not the popover is currently being shown\n         */\n        get: /**\n         * Returns whether or not the popover is currently being shown\n         * @return {?}\n         */ function () {\n            return this._popover.isShown;\n        },\n        set: /**\n         * @param {?} value\n         * @return {?}\n         */ function (value) {\n            if (value) {\n                this.show();\n            }\n            else {\n                this.hide();\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * Opens an element’s popover. This is considered a “manual” triggering of\n     * the popover.\n     */\n    /**\n     * Opens an element’s popover. This is considered a “manual” triggering of\n     * the popover.\n     * @return {?}\n     */\n    PopoverDirective.prototype.show = /**\n     * Opens an element’s popover. This is considered a “manual” triggering of\n     * the popover.\n     * @return {?}\n     */\n        function () {\n            if (this._popover.isShown) {\n                return;\n            }\n            this._positionService.setOptions({\n                modifiers: {\n                    flip: {\n                        enabled: this.dynamicPosition,\n                    },\n                    preventOverflow: {\n                        enabled: this.dynamicPosition,\n                    },\n                },\n            });\n            this._popover\n                .attach(PopoverContainerComponent)\n                .to(this.container)\n                .position({ attachment: this.placement })\n                .show({\n                content: this.mdbPopover,\n                placement: this.placement,\n                title: this.mdbPopoverHeader || this.popoverTitle,\n            });\n            this.isOpen = true;\n            if (!this.dynamicPosition) {\n                this._positionService.calcPosition();\n                this._positionService.deletePositionElement(this._popover._componentRef.location);\n            }\n        };\n    /**\n     * Closes an element’s popover. This is considered a “manual” triggering of\n     * the popover.\n     */\n    /**\n     * Closes an element’s popover. This is considered a “manual” triggering of\n     * the popover.\n     * @return {?}\n     */\n    PopoverDirective.prototype.hide = /**\n     * Closes an element’s popover. This is considered a “manual” triggering of\n     * the popover.\n     * @return {?}\n     */\n        function () {\n            if (this.isOpen) {\n                this._popover.hide();\n                this.isOpen = false;\n            }\n        };\n    /**\n     * Toggles an element’s popover. This is considered a “manual” triggering of\n     * the popover.\n     */\n    /**\n     * Toggles an element’s popover. This is considered a “manual” triggering of\n     * the popover.\n     * @return {?}\n     */\n    PopoverDirective.prototype.toggle = /**\n     * Toggles an element’s popover. This is considered a “manual” triggering of\n     * the popover.\n     * @return {?}\n     */\n        function () {\n            if (this.isOpen) {\n                return this.hide();\n            }\n            this.show();\n        };\n    /**\n     * @param {?} event\n     * @return {?}\n     */\n    PopoverDirective.prototype.onclick = /**\n     * @param {?} event\n     * @return {?}\n     */\n        function (event) {\n            if (this.triggers.toString().includes('focus')) {\n                event.stopPropagation();\n                this.show();\n            }\n        };\n    /**\n     * @return {?}\n     */\n    PopoverDirective.prototype.onblur = /**\n     * @return {?}\n     */\n        function () {\n            if (this.triggers.toString().includes('focus') && this.isOpen) {\n                this.hide();\n            }\n        };\n    // fix(popover): popover with outsideClick='true' will now close after clicking in document on iPad Safari\n    // fix(popover): popover with outsideClick='true' will now close after clicking in document on iPad Safari\n    /**\n     * @param {?} event\n     * @return {?}\n     */\n    PopoverDirective.prototype.onTouchStart =\n        // fix(popover): popover with outsideClick='true' will now close after clicking in document on iPad Safari\n        /**\n         * @param {?} event\n         * @return {?}\n         */\n        function (event) {\n            if (this.outsideClick && !event.target.classList.contains('popover-body')) {\n                this.hide();\n            }\n        };\n    /**\n     * @return {?}\n     */\n    PopoverDirective.prototype.ngOnInit = /**\n     * @return {?}\n     */\n        function () {\n            var _this = this;\n            this._popover.listen({\n                triggers: this.triggers,\n                outsideClick: this.outsideClick,\n                show: (function () { return _this.show(); }),\n            });\n        };\n    /**\n     * @return {?}\n     */\n    PopoverDirective.prototype.dispose = /**\n     * @return {?}\n     */\n        function () {\n            this._popover.dispose();\n        };\n    /**\n     * @return {?}\n     */\n    PopoverDirective.prototype.ngOnDestroy = /**\n     * @return {?}\n     */\n        function () {\n            this._popover.dispose();\n        };\n    return PopoverDirective;\n}());\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\nvar PopoverModule = /*@__PURE__*/ (function () {\n    function PopoverModule() {\n    }\n    /**\n     * @return {?}\n     */\n    PopoverModule.forRoot = /**\n     * @return {?}\n     */\n        function () {\n            return {\n                ngModule: PopoverModule,\n                providers: [PopoverConfig, ComponentLoaderFactory, PositioningService]\n            };\n        };\n    return PopoverModule;\n}());\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\nvar MdbTableDirective = /*@__PURE__*/ (function () {\n    function MdbTableDirective(el, renderer) {\n        this.el = el;\n        this.renderer = renderer;\n        this.stickyHeader = false;\n        this.stickyHeaderBgColor = '';\n        this.stickyHeaderTextColor = '';\n        this._dataSource = [];\n        this._dataSourceChanged = new Subject();\n    }\n    /**\n     * @param {?} newRow\n     * @return {?}\n     */\n    MdbTableDirective.prototype.addRow = /**\n     * @param {?} newRow\n     * @return {?}\n     */\n        function (newRow) {\n            this.getDataSource().push(newRow);\n        };\n    /**\n     * @param {?} index\n     * @param {?} row\n     * @return {?}\n     */\n    MdbTableDirective.prototype.addRowAfter = /**\n     * @param {?} index\n     * @param {?} row\n     * @return {?}\n     */\n        function (index, row) {\n            this.getDataSource().splice(index, 0, row);\n        };\n    /**\n     * @param {?} index\n     * @return {?}\n     */\n    MdbTableDirective.prototype.removeRow = /**\n     * @param {?} index\n     * @return {?}\n     */\n        function (index) {\n            this.getDataSource().splice(index, 1);\n        };\n    /**\n     * @return {?}\n     */\n    MdbTableDirective.prototype.rowRemoved = /**\n     * @return {?}\n     */\n        function () {\n            /** @type {?} */\n            var rowRemoved = new Observable((function (observer) {\n                observer.next(true);\n            }));\n            return rowRemoved;\n        };\n    /**\n     * @return {?}\n     */\n    MdbTableDirective.prototype.removeLastRow = /**\n     * @return {?}\n     */\n        function () {\n            this.getDataSource().pop();\n        };\n    /**\n     * @return {?}\n     */\n    MdbTableDirective.prototype.getDataSource = /**\n     * @return {?}\n     */\n        function () {\n            return this._dataSource;\n        };\n    /**\n     * @param {?} data\n     * @return {?}\n     */\n    MdbTableDirective.prototype.setDataSource = /**\n     * @param {?} data\n     * @return {?}\n     */\n        function (data) {\n            this._dataSource = data;\n            this._dataSourceChanged.next(this.getDataSource());\n        };\n    /**\n     * @return {?}\n     */\n    MdbTableDirective.prototype.dataSourceChange = /**\n     * @return {?}\n     */\n        function () {\n            return this._dataSourceChanged;\n        };\n    /**\n     * @param {?} searchKey\n     * @return {?}\n     */\n    MdbTableDirective.prototype.filterLocalDataBy = /**\n     * @param {?} searchKey\n     * @return {?}\n     */\n        function (searchKey) {\n            return this.getDataSource().filter((function (obj) {\n                return Object.keys(obj).some((function (key) {\n                    if (obj[key]) {\n                        // Fix(tableSearch): table search will now able to filter through nested data\n                        return ((JSON.stringify(obj)\n                            .toLowerCase()\n                            .includes(searchKey)));\n                    }\n                }));\n            }));\n        };\n    /**\n     * @param {?} searchKey\n     * @return {?}\n     */\n    MdbTableDirective.prototype.searchLocalDataBy = /**\n     * @param {?} searchKey\n     * @return {?}\n     */\n        function (searchKey) {\n            if (!searchKey) {\n                return this.getDataSource();\n            }\n            if (searchKey) {\n                return this.filterLocalDataBy(searchKey.toLowerCase());\n            }\n        };\n    /**\n     * @param {?} searchKey\n     * @return {?}\n     */\n    MdbTableDirective.prototype.searchDataObservable = /**\n     * @param {?} searchKey\n     * @return {?}\n     */\n        function (searchKey) {\n            var _this = this;\n            /** @type {?} */\n            var observable = new Observable((function (observer) {\n                observer.next(_this.searchLocalDataBy(searchKey));\n            }));\n            return observable;\n        };\n    /**\n     * @return {?}\n     */\n    MdbTableDirective.prototype.ngOnInit = /**\n     * @return {?}\n     */\n        function () {\n            this.renderer.addClass(this.el.nativeElement, 'table');\n        };\n    /**\n     * @return {?}\n     */\n    MdbTableDirective.prototype.ngAfterViewInit = /**\n     * @return {?}\n     */\n        function () {\n            var _this = this;\n            // Fix(stickyHeader): resolved problem with not working stickyHeader=\"true\" on Chrome\n            if (this.stickyHeader) {\n                /** @type {?} */\n                var tableHead = this.el.nativeElement.querySelector('thead');\n                Array.from(tableHead.firstElementChild.children).forEach((function (child) {\n                    _this.renderer.addClass(child, 'sticky-top');\n                    if (_this.stickyHeaderBgColor) {\n                        _this.renderer.setStyle(child, 'background-color', _this.stickyHeaderBgColor);\n                    }\n                    else {\n                        _this.renderer.setStyle(child, 'background-color', '#f2f2f2');\n                    }\n                    if (_this.stickyHeaderTextColor) {\n                        _this.renderer.setStyle(child, 'color', _this.stickyHeaderTextColor);\n                    }\n                    else {\n                        _this.renderer.setStyle(child, 'color', '#000000');\n                    }\n                }));\n            }\n        };\n    return MdbTableDirective;\n}());\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\nvar MdbTableSortDirective = /*@__PURE__*/ (function () {\n    function MdbTableSortDirective(el, renderer) {\n        this.el = el;\n        this.renderer = renderer;\n        this.sorted = true;\n        this.dataSource = [];\n        this.sortEnd = new EventEmitter();\n    }\n    /**\n     * @return {?}\n     */\n    MdbTableSortDirective.prototype.onclick = /**\n     * @return {?}\n     */\n        function () {\n            this.sortDataBy(this.trimWhiteSigns(this.sortBy.toString()));\n            this.sortEnd.emit(this.dataSource);\n        };\n    /**\n     * @param {?} headElement\n     * @return {?}\n     */\n    MdbTableSortDirective.prototype.trimWhiteSigns = /**\n     * @param {?} headElement\n     * @return {?}\n     */\n        function (headElement) {\n            return headElement.replace(/ /g, '');\n        };\n    /**\n     * @param {?} arr\n     * @param {?} oldIndex\n     * @param {?} newIndex\n     * @return {?}\n     */\n    MdbTableSortDirective.prototype.moveArrayItem = /**\n     * @param {?} arr\n     * @param {?} oldIndex\n     * @param {?} newIndex\n     * @return {?}\n     */\n        function (arr, oldIndex, newIndex) {\n            while (oldIndex < 0) {\n                oldIndex += arr.length;\n            }\n            while (newIndex < 0) {\n                newIndex += arr.length;\n            }\n            if (newIndex >= arr.length) {\n                /** @type {?} */\n                var k = newIndex - arr.length;\n                while ((k--) + 1) {\n                    arr.push(null);\n                }\n            }\n            arr.splice(newIndex, 0, arr.splice(oldIndex, 1)[0]);\n            return arr;\n        };\n    /**\n     * @param {?} key\n     * @return {?}\n     */\n    MdbTableSortDirective.prototype.sortDataBy = /**\n     * @param {?} key\n     * @return {?}\n     */\n        function (key) {\n            var _this = this;\n            key = key.split('.');\n            this.dataSource.sort((function (a, b) {\n                /** @type {?} */\n                var i = 0;\n                while (i < key.length) {\n                    a = a[key[i]];\n                    b = b[key[i]];\n                    i++;\n                }\n                if (a < b) {\n                    _this.renderer.setAttribute(_this.el.nativeElement, 'aria-sort', 'ascending');\n                    _this.renderer.setAttribute(_this.el.nativeElement, 'aria-label', key + \": activate to sort column descending\");\n                    return _this.sorted ? 1 : -1;\n                }\n                else if (a > b) {\n                    _this.renderer.setAttribute(_this.el.nativeElement, 'aria-sort', 'descending');\n                    _this.renderer.setAttribute(_this.el.nativeElement, 'aria-label', key + \": activate to sort column ascending\");\n                    return _this.sorted ? -1 : 1;\n                }\n                else if (a == null || b == null) {\n                    return 1;\n                }\n                else {\n                    return 0;\n                }\n            }));\n            this.sorted = !this.sorted;\n        };\n    /**\n     * @return {?}\n     */\n    MdbTableSortDirective.prototype.ngOnInit = /**\n     * @return {?}\n     */\n        function () {\n            /** @type {?} */\n            var key = this.trimWhiteSigns(this.sortBy.toString()).split('.');\n            this.renderer.setAttribute(this.el.nativeElement, 'aria-label', key + \": activate to sort column descending\");\n        };\n    return MdbTableSortDirective;\n}());\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\nvar MdbTableScrollDirective = /*@__PURE__*/ (function () {\n    function MdbTableScrollDirective(renderer, el) {\n        this.renderer = renderer;\n        this.el = el;\n        this.scrollY = false;\n        this.maxHeight = null;\n        this.scrollX = false;\n        this.maxWidth = null;\n    }\n    /**\n     * @param {?} tableWrapper\n     * @return {?}\n     */\n    MdbTableScrollDirective.prototype.wrapTableWithVerticalScrollingWrapper = /**\n     * @param {?} tableWrapper\n     * @return {?}\n     */\n        function (tableWrapper) {\n            this.renderer.setStyle(tableWrapper, 'max-height', this.maxHeight + 'px');\n            this.renderer.setStyle(tableWrapper, 'overflow-y', 'auto');\n            this.renderer.setStyle(tableWrapper, 'display', 'block');\n        };\n    /**\n     * @param {?} tableWrapper\n     * @return {?}\n     */\n    MdbTableScrollDirective.prototype.wrapTableWithHorizontalScrollingWrapper = /**\n     * @param {?} tableWrapper\n     * @return {?}\n     */\n        function (tableWrapper) {\n            this.renderer.setStyle(tableWrapper, 'max-width', this.maxWidth + 'px');\n            this.renderer.setStyle(tableWrapper, 'overflow-x', 'auto');\n            this.renderer.setStyle(tableWrapper, 'display', 'block');\n        };\n    /**\n     * @param {?} tableWrapper\n     * @return {?}\n     */\n    MdbTableScrollDirective.prototype.wrapTableWithHorizontalAndVerticalScrollingWrapper = /**\n     * @param {?} tableWrapper\n     * @return {?}\n     */\n        function (tableWrapper) {\n            this.renderer.setStyle(tableWrapper, 'max-height', this.maxHeight + 'px');\n            this.renderer.setStyle(tableWrapper, 'max-width', this.maxWidth + 'px');\n            this.renderer.setStyle(tableWrapper, 'overflow-x', 'auto');\n            this.renderer.setStyle(tableWrapper, 'display', 'block');\n        };\n    /**\n     * @return {?}\n     */\n    MdbTableScrollDirective.prototype.ngOnInit = /**\n     * @return {?}\n     */\n        function () {\n            /** @type {?} */\n            var parent = this.el.nativeElement.parentNode;\n            /** @type {?} */\n            var tableWrapper = this.renderer.createElement('div');\n            if (this.scrollY && this.scrollX && this.maxHeight && this.maxWidth) {\n                this.wrapTableWithHorizontalAndVerticalScrollingWrapper(tableWrapper);\n            }\n            if (this.scrollY && this.maxHeight) {\n                this.wrapTableWithVerticalScrollingWrapper(tableWrapper);\n            }\n            if (this.scrollX && this.maxWidth) {\n                this.wrapTableWithHorizontalScrollingWrapper(tableWrapper);\n            }\n            this.renderer.insertBefore(parent, tableWrapper, this.el.nativeElement);\n            this.renderer.removeChild(parent, this.el.nativeElement);\n            this.renderer.appendChild(tableWrapper, this.el.nativeElement);\n        };\n    return MdbTableScrollDirective;\n}());\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\nvar MdbTableRowDirective = /*@__PURE__*/ (function () {\n    function MdbTableRowDirective(el) {\n        this.el = el;\n        this.rowCreated = new EventEmitter();\n        this.rowRemoved = new EventEmitter();\n    }\n    /**\n     * @return {?}\n     */\n    MdbTableRowDirective.prototype.ngOnInit = /**\n     * @return {?}\n     */\n        function () {\n            this.rowCreated.emit({ created: true, el: this.el.nativeElement });\n        };\n    /**\n     * @return {?}\n     */\n    MdbTableRowDirective.prototype.ngOnDestroy = /**\n     * @return {?}\n     */\n        function () {\n            this.rowRemoved.emit({ removed: true });\n        };\n    return MdbTableRowDirective;\n}());\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\nvar MdbTableService = /*@__PURE__*/ (function () {\n    function MdbTableService() {\n        this._dataSource = [];\n        this._dataSourceChanged = new Subject();\n    }\n    /**\n     * @param {?} newRow\n     * @return {?}\n     */\n    MdbTableService.prototype.addRow = /**\n     * @param {?} newRow\n     * @return {?}\n     */\n        function (newRow) {\n            this.getDataSource().push(newRow);\n        };\n    /**\n     * @param {?} index\n     * @param {?} row\n     * @return {?}\n     */\n    MdbTableService.prototype.addRowAfter = /**\n     * @param {?} index\n     * @param {?} row\n     * @return {?}\n     */\n        function (index, row) {\n            this.getDataSource().splice(index, 0, row);\n        };\n    /**\n     * @param {?} index\n     * @return {?}\n     */\n    MdbTableService.prototype.removeRow = /**\n     * @param {?} index\n     * @return {?}\n     */\n        function (index) {\n            this.getDataSource().splice(index, 1);\n        };\n    /**\n     * @return {?}\n     */\n    MdbTableService.prototype.rowRemoved = /**\n     * @return {?}\n     */\n        function () {\n            /** @type {?} */\n            var rowRemoved = new Observable((function (observer) {\n                observer.next(true);\n            }));\n            return rowRemoved;\n        };\n    /**\n     * @return {?}\n     */\n    MdbTableService.prototype.removeLastRow = /**\n     * @return {?}\n     */\n        function () {\n            this.getDataSource().pop();\n        };\n    /**\n     * @return {?}\n     */\n    MdbTableService.prototype.getDataSource = /**\n     * @return {?}\n     */\n        function () {\n            return this._dataSource;\n        };\n    /**\n     * @param {?} data\n     * @return {?}\n     */\n    MdbTableService.prototype.setDataSource = /**\n     * @param {?} data\n     * @return {?}\n     */\n        function (data) {\n            this._dataSource = data;\n            this._dataSourceChanged.next(this.getDataSource());\n        };\n    /**\n     * @return {?}\n     */\n    MdbTableService.prototype.dataSourceChange = /**\n     * @return {?}\n     */\n        function () {\n            return this._dataSourceChanged;\n        };\n    /**\n     * @param {?} searchKey\n     * @return {?}\n     */\n    MdbTableService.prototype.filterLocalDataBy = /**\n     * @param {?} searchKey\n     * @return {?}\n     */\n        function (searchKey) {\n            return this.getDataSource().filter((function (obj) {\n                return Object.keys(obj).some((function (key) {\n                    if (obj[key]) {\n                        return obj[key]\n                            .toString()\n                            .toLowerCase()\n                            .includes(searchKey);\n                    }\n                }));\n            }));\n        };\n    /**\n     * @param {?} searchKey\n     * @return {?}\n     */\n    MdbTableService.prototype.searchLocalDataBy = /**\n     * @param {?} searchKey\n     * @return {?}\n     */\n        function (searchKey) {\n            if (!searchKey) {\n                return this.getDataSource();\n            }\n            if (searchKey) {\n                return this.filterLocalDataBy(searchKey.toLowerCase());\n            }\n        };\n    /**\n     * @param {?} searchKey\n     * @return {?}\n     */\n    MdbTableService.prototype.searchDataObservable = /**\n     * @param {?} searchKey\n     * @return {?}\n     */\n        function (searchKey) {\n            var _this = this;\n            /** @type {?} */\n            var observable = new Observable((function (observer) {\n                observer.next(_this.searchLocalDataBy(searchKey));\n            }));\n            return observable;\n        };\n    /** @nocollapse */ MdbTableService.ngInjectableDef = ɵɵdefineInjectable({ factory: function MdbTableService_Factory() { return new MdbTableService(); }, token: MdbTableService, providedIn: \"root\" });\n    return MdbTableService;\n}());\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\nvar MdbTablePaginationComponent = /*@__PURE__*/ (function () {\n    function MdbTablePaginationComponent(cdRef) {\n        this.cdRef = cdRef;\n        this.searchPagination = false;\n        this.searchDataSource = null;\n        this.ofKeyword = 'of';\n        this.dashKeyword = '-';\n        this.paginationAlign = '';\n        this.hideDescription = false;\n        this.maxVisibleItems = 10;\n        this.firstItemIndex = 0;\n        this.lastItemIndex = this.maxVisibleItems;\n        this.lastVisibleItemIndex = 5;\n        this.activePageNumber = 1;\n        this.allItemsLength = 0;\n        this.nextShouldBeDisabled = false;\n        this.previousShouldBeDisabled = true;\n        this.searchText = '';\n        this.pagination = new Subject();\n        this.nextPageClick = new EventEmitter();\n        this.previousPageClick = new EventEmitter();\n    }\n    /**\n     * @return {?}\n     */\n    MdbTablePaginationComponent.prototype.ngOnInit = /**\n     * @return {?}\n     */\n        function () {\n            if (this.tableEl) {\n                this.allItemsLength = this.tableEl.getDataSource().length;\n            }\n        };\n    /**\n     * @return {?}\n     */\n    MdbTablePaginationComponent.prototype.ngAfterViewInit = /**\n     * @return {?}\n     */\n        function () {\n            var _this = this;\n            if (this.tableEl) {\n                this.tableEl.dataSourceChange().subscribe((function (data) {\n                    _this.allItemsLength = data.length;\n                    _this.lastVisibleItemIndex = data.length;\n                    _this.calculateFirstItemIndex();\n                    _this.calculateLastItemIndex();\n                    _this.disableNextButton(data);\n                    if (_this.searchDataSource) {\n                        setTimeout((function () {\n                            if (_this.searchDataSource.length !== data.length) {\n                                _this.activePageNumber = 1;\n                                _this.firstItemIndex = 1;\n                            }\n                        }), 0);\n                    }\n                }));\n            }\n            this.paginationChange().subscribe((function (data) {\n                _this.firstItemIndex = data.first;\n                _this.lastVisibleItemIndex = data.last;\n            }));\n        };\n    /**\n     * @param {?} changes\n     * @return {?}\n     */\n    MdbTablePaginationComponent.prototype.ngOnChanges = /**\n     * @param {?} changes\n     * @return {?}\n     */\n        function (changes) {\n            /** @type {?} */\n            var searchDataSource = changes['searchDataSource'];\n            if (searchDataSource.currentValue.length !== 0) {\n                this.allItemsLength = searchDataSource.currentValue.length;\n            }\n            if (this.lastVisibleItemIndex > this.allItemsLength) {\n                this.lastVisibleItemIndex = this.allItemsLength;\n            }\n            if (searchDataSource.currentValue.length === 0) {\n                this.firstItemIndex = 0;\n                this.lastItemIndex = 0;\n                this.lastVisibleItemIndex = 0;\n                this.allItemsLength = 0;\n            }\n            if (!searchDataSource.isFirstChange() &&\n                searchDataSource.currentValue.length <= this.maxVisibleItems) {\n                this.nextShouldBeDisabled = true;\n                this.lastVisibleItemIndex = searchDataSource.currentValue.length;\n            }\n            else {\n                this.nextShouldBeDisabled = false;\n            }\n        };\n    /**\n     * @param {?} value\n     * @return {?}\n     */\n    MdbTablePaginationComponent.prototype.setMaxVisibleItemsNumberTo = /**\n     * @param {?} value\n     * @return {?}\n     */\n        function (value) {\n            this.lastItemIndex = value;\n            this.lastVisibleItemIndex = value;\n            this.maxVisibleItems = value;\n            this.cdRef.detectChanges();\n        };\n    /**\n     * @return {?}\n     */\n    MdbTablePaginationComponent.prototype.searchTextObs = /**\n     * @return {?}\n     */\n        function () {\n            var _this = this;\n            /** @type {?} */\n            var observable = new Observable((function (observer) {\n                observer.next(_this.searchText);\n            }));\n            return observable;\n        };\n    /**\n     * @param {?} data\n     * @return {?}\n     */\n    MdbTablePaginationComponent.prototype.disableNextButton = /**\n     * @param {?} data\n     * @return {?}\n     */\n        function (data) {\n            if (data.length <= this.maxVisibleItems) {\n                this.nextShouldBeDisabled = true;\n            }\n            else {\n                this.nextShouldBeDisabled = false;\n            }\n        };\n    /**\n     * @return {?}\n     */\n    MdbTablePaginationComponent.prototype.calculateFirstItemIndex = /**\n     * @return {?}\n     */\n        function () {\n            this.firstItemIndex = this.activePageNumber * this.maxVisibleItems - this.maxVisibleItems + 1;\n            this.pagination.next({ first: this.firstItemIndex, last: this.lastItemIndex });\n        };\n    /**\n     * @return {?}\n     */\n    MdbTablePaginationComponent.prototype.calculateLastItemIndex = /**\n     * @return {?}\n     */\n        function () {\n            this.lastItemIndex = this.activePageNumber * this.maxVisibleItems;\n            this.lastVisibleItemIndex = this.lastItemIndex;\n            if (this.searchDataSource && this.lastItemIndex > this.searchDataSource.length) {\n                this.lastVisibleItemIndex = this.searchDataSource.length;\n            }\n            else if (!this.searchDataSource) {\n                this.lastVisibleItemIndex = this.lastItemIndex;\n            }\n            if (this.lastItemIndex > this.tableEl.getDataSource().length) {\n                this.lastItemIndex = this.tableEl.getDataSource().length;\n                this.lastVisibleItemIndex = this.tableEl.getDataSource().length;\n            }\n            this.pagination.next({ first: this.firstItemIndex, last: this.lastItemIndex });\n        };\n    /**\n     * @return {?}\n     */\n    MdbTablePaginationComponent.prototype.paginationChange = /**\n     * @return {?}\n     */\n        function () {\n            return this.pagination;\n        };\n    /**\n     * @return {?}\n     */\n    MdbTablePaginationComponent.prototype.calculateHowManyPagesShouldBe = /**\n     * @return {?}\n     */\n        function () {\n            return Math.ceil(this.tableEl.getDataSource().length / this.maxVisibleItems);\n        };\n    /**\n     * @return {?}\n     */\n    MdbTablePaginationComponent.prototype.previousPage = /**\n     * @return {?}\n     */\n        function () {\n            this.activePageNumber--;\n            this.calculateFirstItemIndex();\n            this.calculateLastItemIndex();\n            this.previousPageClick.emit({ first: this.firstItemIndex, last: this.lastItemIndex });\n        };\n    /**\n     * @return {?}\n     */\n    MdbTablePaginationComponent.prototype.nextPage = /**\n     * @return {?}\n     */\n        function () {\n            this.activePageNumber++;\n            this.calculateFirstItemIndex();\n            this.calculateLastItemIndex();\n            if (this.lastItemIndex > this.tableEl.getDataSource().length) {\n                this.lastItemIndex = this.tableEl.getDataSource().length;\n            }\n            if (this.lastVisibleItemIndex > this.allItemsLength) {\n                this.lastVisibleItemIndex = this.allItemsLength;\n            }\n            this.nextPageClick.emit({ first: this.firstItemIndex, last: this.lastItemIndex });\n        };\n    /**\n     * @return {?}\n     */\n    MdbTablePaginationComponent.prototype.firstPage = /**\n     * @return {?}\n     */\n        function () {\n            this.activePageNumber = 1;\n            this.calculateFirstItemIndex();\n            this.calculateLastItemIndex();\n        };\n    /**\n     * @return {?}\n     */\n    MdbTablePaginationComponent.prototype.lastPage = /**\n     * @return {?}\n     */\n        function () {\n            /** @type {?} */\n            var lastPage = Math.round(this.allItemsLength / this.maxVisibleItems);\n            this.activePageNumber = lastPage;\n            this.calculateFirstItemIndex();\n            this.calculateLastItemIndex();\n        };\n    /**\n     * @return {?}\n     */\n    MdbTablePaginationComponent.prototype.nextPageObservable = /**\n     * @return {?}\n     */\n        function () {\n            var _this = this;\n            /** @type {?} */\n            var obs = new Observable((function (observer) {\n                observer.next(_this.firstItemIndex);\n            }));\n            return obs;\n        };\n    /**\n     * @return {?}\n     */\n    MdbTablePaginationComponent.prototype.previousPageObservable = /**\n     * @return {?}\n     */\n        function () {\n            var _this = this;\n            /** @type {?} */\n            var obs = new Observable((function (observer) {\n                observer.next(_this.lastVisibleItemIndex);\n            }));\n            return obs;\n        };\n    /**\n     * @return {?}\n     */\n    MdbTablePaginationComponent.prototype.checkIfNextShouldBeDisabled = /**\n     * @return {?}\n     */\n        function () {\n            if (this.searchDataSource && this.lastVisibleItemIndex === this.searchDataSource.length) {\n                return true;\n            }\n            if (this.activePageNumber >= this.calculateHowManyPagesShouldBe()) {\n                return true;\n            }\n            if (this.nextShouldBeDisabled) {\n                return this.nextShouldBeDisabled;\n            }\n        };\n    /**\n     * @return {?}\n     */\n    MdbTablePaginationComponent.prototype.checkIfPreviousShouldBeDisabled = /**\n     * @return {?}\n     */\n        function () {\n            if (this.activePageNumber === 1) {\n                return true;\n            }\n        };\n    return MdbTablePaginationComponent;\n}());\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\nvar TableModule = /*@__PURE__*/ (function () {\n    function TableModule() {\n    }\n    return TableModule;\n}());\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * Default values provider for tooltip\n */\nvar TooltipConfig = /*@__PURE__*/ (function () {\n    function TooltipConfig() {\n        /**\n         * tooltip placement, supported positions: 'top', 'bottom', 'left', 'right'\n         */\n        this.placement = 'top';\n        /**\n         * array of event names which triggers tooltip opening\n         */\n        this.triggers = 'hover focus';\n    }\n    return TooltipConfig;\n}());\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\nvar TooltipContainerComponent = /*@__PURE__*/ (function () {\n    function TooltipContainerComponent(config, elem) {\n        this.containerClass = '';\n        this.show = !this.isBs3;\n        this.el = elem;\n        Object.assign(this, config);\n    }\n    Object.defineProperty(TooltipContainerComponent.prototype, \"tooltipClasses\", {\n        get: /**\n         * @return {?}\n         */ function () {\n            return \"tooltip-fadeIn tooltip in tooltip-\" + this.placement + \" bs-tooltip-\" + this.placement + \" \" + this.placement + \" \" + this.containerClass;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(TooltipContainerComponent.prototype, \"isBs3\", {\n        get: /**\n         * @return {?}\n         */ function () {\n            return isBs3();\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * @return {?}\n     */\n    TooltipContainerComponent.prototype.ngAfterViewInit = /**\n     * @return {?}\n     */\n        function () {\n            this.classMap = { in: false, fade: false };\n            this.classMap[this.placement] = true;\n            this.classMap['tooltip-' + this.placement] = true;\n            this.classMap.in = true;\n            if (this.animation) {\n                this.classMap.fade = true;\n            }\n            if (this.popupClass) {\n                this.classMap[this.popupClass] = true;\n            }\n        };\n    return TooltipContainerComponent;\n}());\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\nvar TooltipDirective = /*@__PURE__*/ (function () {\n    function TooltipDirective(_renderer, _elementRef, _positionService, _viewContainerRef, cis, config, platformId) {\n        this._elementRef = _elementRef;\n        this._positionService = _positionService;\n        this.platformId = platformId;\n        /**\n         * Fired when tooltip content changes\n         */\n        this.tooltipChange = new EventEmitter();\n        this.dynamicPosition = true;\n        this.delay = 0;\n        this.fadeDuration = 150;\n        this.isBrowser = false;\n        this.isBrowser = isPlatformBrowser(this.platformId);\n        this._tooltip = cis\n            .createLoader(this._elementRef, _viewContainerRef, _renderer)\n            .provide({ provide: TooltipConfig, useValue: config });\n        Object.assign(this, config);\n        this.onShown = this._tooltip.onShown;\n        this.shown = this._tooltip.onShown;\n        this.onHidden = this._tooltip.onHidden;\n        this.hidden = this._tooltip.onHidden;\n    }\n    Object.defineProperty(TooltipDirective.prototype, \"isOpen\", {\n        /**\n         * Returns whether or not the tooltip is currently being shown\n         */\n        get: /**\n         * Returns whether or not the tooltip is currently being shown\n         * @return {?}\n         */ function () {\n            return this._tooltip.isShown;\n        },\n        set: /**\n         * @param {?} value\n         * @return {?}\n         */ function (value) {\n            if (value) {\n                this.show();\n            }\n            else {\n                this.hide();\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * @return {?}\n     */\n    TooltipDirective.prototype.ngOnInit = /**\n     * @return {?}\n     */\n        function () {\n            var _this = this;\n            this._tooltip.listen({\n                triggers: this.triggers,\n                show: (function () { return _this.show(); }),\n            });\n            this.tooltipChange.subscribe((function (value) {\n                if (!value) {\n                    _this._tooltip.hide();\n                }\n            }));\n        };\n    /**\n     * @param {?} changes\n     * @return {?}\n     */\n    TooltipDirective.prototype.ngOnChanges = /**\n     * @param {?} changes\n     * @return {?}\n     */\n        function (changes) {\n            if (!changes['mdbTooltip'].isFirstChange()) {\n                this.tooltipChange.emit(this.mdbTooltip);\n            }\n        };\n    /**\n     * Toggles an element’s tooltip. This is considered a “manual” triggering of\n     * the tooltip.\n     */\n    /**\n     * Toggles an element’s tooltip. This is considered a “manual” triggering of\n     * the tooltip.\n     * @return {?}\n     */\n    TooltipDirective.prototype.toggle = /**\n     * Toggles an element’s tooltip. This is considered a “manual” triggering of\n     * the tooltip.\n     * @return {?}\n     */\n        function () {\n            if (this.isOpen) {\n                return this.hide();\n            }\n            this.show();\n        };\n    /**\n     * Opens an element’s tooltip. This is considered a “manual” triggering of\n     * the tooltip.\n     */\n    /**\n     * Opens an element’s tooltip. This is considered a “manual” triggering of\n     * the tooltip.\n     * @return {?}\n     */\n    TooltipDirective.prototype.show = /**\n     * Opens an element’s tooltip. This is considered a “manual” triggering of\n     * the tooltip.\n     * @return {?}\n     */\n        function () {\n            var _this = this;\n            if (this.isOpen || this.isDisabled || this._delayTimeoutId || !this.mdbTooltip) {\n                return;\n            }\n            this._positionService.setOptions({\n                modifiers: {\n                    flip: {\n                        enabled: this.dynamicPosition,\n                    },\n                    preventOverflow: {\n                        enabled: this.dynamicPosition,\n                    },\n                },\n            });\n            /** @type {?} */\n            var showTooltip = (function () {\n                _this._tooltip\n                    .attach(TooltipContainerComponent)\n                    .to(_this.container)\n                    .position({ attachment: _this.placement })\n                    .show({\n                    content: _this.mdbTooltip,\n                    placement: _this.placement,\n                });\n            });\n            this.showTooltip(showTooltip);\n        };\n    /**\n     * @private\n     * @param {?} fn\n     * @return {?}\n     */\n    TooltipDirective.prototype.showTooltip = /**\n     * @private\n     * @param {?} fn\n     * @return {?}\n     */\n        function (fn) {\n            if (this.delay) {\n                this._delayTimeoutId = setTimeout((function () {\n                    fn();\n                }), this.delay);\n            }\n            else {\n                fn();\n            }\n        };\n    /**\n     * Closes an element’s tooltip. This is considered a “manual” triggering of\n     * the tooltip.\n     */\n    /**\n     * Closes an element’s tooltip. This is considered a “manual” triggering of\n     * the tooltip.\n     * @return {?}\n     */\n    TooltipDirective.prototype.hide = /**\n     * Closes an element’s tooltip. This is considered a “manual” triggering of\n     * the tooltip.\n     * @return {?}\n     */\n        function () {\n            var _this = this;\n            if (this._delayTimeoutId) {\n                clearTimeout(this._delayTimeoutId);\n                this._delayTimeoutId = undefined;\n            }\n            if (!this._tooltip.isShown) {\n                return;\n            }\n            this._tooltip.instance.classMap.in = false;\n            setTimeout((function () {\n                _this._tooltip.hide();\n            }), this.fadeDuration);\n        };\n    /**\n     * @return {?}\n     */\n    TooltipDirective.prototype.dispose = /**\n     * @return {?}\n     */\n        function () {\n            this._tooltip.dispose();\n        };\n    /**\n     * @return {?}\n     */\n    TooltipDirective.prototype.ngOnDestroy = /**\n     * @return {?}\n     */\n        function () {\n            this._tooltip.dispose();\n        };\n    __decorate([\n        OnChange$1(),\n        __metadata(\"design:type\", Object)\n    ], TooltipDirective.prototype, \"mdbTooltip\", void 0);\n    return TooltipDirective;\n}());\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\nvar TooltipModule = /*@__PURE__*/ (function () {\n    function TooltipModule() {\n    }\n    /**\n     * @return {?}\n     */\n    TooltipModule.forRoot = /**\n     * @return {?}\n     */\n        function () {\n            return {\n                ngModule: TooltipModule,\n                providers: [TooltipConfig, ComponentLoaderFactory, PositioningService]\n            };\n        };\n    return TooltipModule;\n}());\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\nvar WavesDirective = /*@__PURE__*/ (function () {\n    function WavesDirective(el) {\n        this.el = el;\n    }\n    /**\n     * @param {?} event\n     * @return {?}\n     */\n    WavesDirective.prototype.click = /**\n     * @param {?} event\n     * @return {?}\n     */\n        function (event) {\n            // event.stopPropagation();\n            if (!this.el.nativeElement.classList.contains('disabled')) {\n                /** @type {?} */\n                var button = this.el.nativeElement;\n                if (!button.classList.contains('waves-effect')) {\n                    button.className += ' waves-effect';\n                }\n                /** @type {?} */\n                var xPos = event.clientX - button.getBoundingClientRect().left;\n                /** @type {?} */\n                var yPos = event.clientY - button.getBoundingClientRect().top;\n                /** @type {?} */\n                var tmp = document.createElement('div');\n                tmp.className += 'waves-ripple waves-rippling';\n                /** @type {?} */\n                var ripple = button.appendChild(tmp);\n                /** @type {?} */\n                var top_1 = yPos + 'px';\n                /** @type {?} */\n                var left = xPos + 'px';\n                tmp.style.top = top_1;\n                tmp.style.left = left;\n                /** @type {?} */\n                var scale = 'scale(' + (button.clientWidth / 100) * 3 + ') translate(0,0)';\n                // tslint:disable-next-line: deprecation\n                tmp.style.webkitTransform = scale;\n                tmp.style.transform = scale;\n                tmp.style.opacity = '1';\n                /** @type {?} */\n                var duration = 750;\n                // tslint:disable-next-line: deprecation\n                tmp.style.webkitTransitionDuration = duration + 'ms';\n                tmp.style.transitionDuration = duration + 'ms';\n                this.removeRipple(button, ripple);\n            }\n        };\n    /**\n     * @param {?} button\n     * @param {?} ripple\n     * @return {?}\n     */\n    WavesDirective.prototype.removeRipple = /**\n     * @param {?} button\n     * @param {?} ripple\n     * @return {?}\n     */\n        function (button, ripple) {\n            ripple.classList.remove('waves-rippling');\n            setTimeout((function () {\n                ripple.style.opacity = '0';\n                setTimeout((function () {\n                    button.removeChild(ripple);\n                }), 750);\n            }), 200);\n        };\n    return WavesDirective;\n}());\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\nvar WavesModule = /*@__PURE__*/ (function () {\n    function WavesModule() {\n    }\n    /**\n     * @return {?}\n     */\n    WavesModule.forRoot = /**\n     * @return {?}\n     */\n        function () {\n            return { ngModule: WavesModule, providers: [] };\n        };\n    return WavesModule;\n}());\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/** @enum {string} */\nvar Direction$1 = {\n    Up: 'Up',\n    Down: 'Down',\n};\nvar StickyHeaderDirective = /*@__PURE__*/ (function () {\n    function StickyHeaderDirective(_renderer, _el) {\n        this._renderer = _renderer;\n        this._el = _el;\n        this.animationDuration = 200;\n        this.transitionEnd = new EventEmitter();\n    }\n    /**\n     * @return {?}\n     */\n    StickyHeaderDirective.prototype.ngAfterViewInit = /**\n     * @return {?}\n     */\n        function () {\n            var _this = this;\n            /** @type {?} */\n            var scroll$ = fromEvent(win, 'scroll').pipe(throttleTime(10), map((function () { return win.pageYOffset; })), pairwise(), map((function (_a) {\n                var _b = __read(_a, 2), y1 = _b[0], y2 = _b[1];\n                return (y2 < y1 ? Direction$1.Up : Direction$1.Down);\n            })), distinctUntilChanged(), share());\n            this.scrollUp$ = scroll$.pipe(filter((function (direction) { return direction === Direction$1.Up; })));\n            this.scrollDown$ = scroll$.pipe(filter((function (direction) { return direction === Direction$1.Down; })));\n            this._renderer.setStyle(this._el.nativeElement, 'position', 'fixed');\n            this._renderer.setStyle(this._el.nativeElement, 'top', '0');\n            this._renderer.setStyle(this._el.nativeElement, 'width', '100%');\n            setTimeout((function () {\n                _this.scrollUp$.pipe(skip(0)).subscribe((function () {\n                    _this._renderer.setStyle(_this._el.nativeElement, 'transition', \"all \" + _this.animationDuration + \"ms ease-in\");\n                    _this._renderer.setStyle(_this._el.nativeElement, 'transform', 'translateY(0%)');\n                    _this.transitionEnd.emit({ state: 'Visible' });\n                }));\n                _this.scrollDown$.pipe(skip(0)).subscribe((function () {\n                    _this._renderer.setStyle(_this._el.nativeElement, 'transition', \"all \" + _this.animationDuration + \"ms ease-in\");\n                    _this._renderer.setStyle(_this._el.nativeElement, 'transform', 'translateY(-100%)');\n                    _this.transitionEnd.emit({ state: 'Hidden' });\n                }));\n            }), 0);\n        };\n    return StickyHeaderDirective;\n}());\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\nvar StickyHeaderModule = /*@__PURE__*/ (function () {\n    function StickyHeaderModule() {\n    }\n    return StickyHeaderModule;\n}());\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/** @type {?} */\nvar MODULES = [\n    ButtonsModule,\n    CardsModule,\n    WavesModule,\n    InputsModule,\n    NavbarModule,\n    DropdownModule,\n    CarouselModule,\n    ChartsModule,\n    CollapseModule,\n    ModalModule,\n    TooltipModule,\n    PopoverModule,\n    IconsModule,\n    CheckboxModule,\n    TableModule,\n    BadgeModule,\n    BreadcrumbModule,\n    InputUtilitiesModule,\n    StickyHeaderModule,\n];\nvar MDBRootModule = /*@__PURE__*/ (function () {\n    function MDBRootModule() {\n    }\n    return MDBRootModule;\n}());\nvar MDBBootstrapModule = /*@__PURE__*/ (function () {\n    function MDBBootstrapModule() {\n    }\n    /**\n     * @return {?}\n     */\n    MDBBootstrapModule.forRoot = /**\n     * @return {?}\n     */\n        function () {\n            return { ngModule: MDBRootModule };\n        };\n    return MDBBootstrapModule;\n}());\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\nexport { BadgeModule, MDBBadgeComponent, MdbBreadcrumbComponent, MdbBreadcrumbItemComponent, BreadcrumbModule, MdbBtnDirective, ButtonsModule, ButtonRadioDirective, ButtonCheckboxDirective, FixedButtonCaptionDirective, CardsModule, MdbCardComponent, MdbCardBodyComponent, MdbCardImageComponent, MdbCardTextComponent, MdbCardTitleComponent, MdbCardFooterComponent, MdbCardHeaderComponent, CarouselComponent, CarouselModule, SlideComponent, CarouselConfig, ChartsModule, BaseChartDirective, CHECKBOX_VALUE_ACCESSOR, CheckboxComponent, MdbCheckboxChange, CheckboxModule, CollapseComponent, CollapseModule, BsDropdownDirective, BsDropdownMenuDirective, BsDropdownToggleDirective, BsDropdownContainerComponent, BsDropdownState, BsDropdownConfig, DropdownModule, MdbIconComponent, FalDirective, FarDirective, FasDirective, FabDirective, IconsModule, InputUtilitiesModule, MdbErrorDirective, MdbSuccessDirective, MdbValidateDirective, InputsModule, EqualValidatorDirective, MdbInputDirective, MdbInput, ModalBackdropComponent, ModalBackdropOptions, ModalOptions, MDBModalRef, ModalDirective, ModalModule, MDBModalService, ModalContainerComponent, NavbarComponent, NavbarModule, LinksComponent, NavlinksComponent, LogoComponent, NavbarService, PopoverDirective, PopoverModule, PopoverConfig, PopoverContainerComponent, TableModule, MdbTablePaginationComponent, MdbTableRowDirective, MdbTableScrollDirective, MdbTableSortDirective, MdbTableDirective, MdbTableService, TooltipContainerComponent, TooltipDirective, TooltipModule, TooltipConfig, WavesDirective, WavesModule, StickyHeaderDirective, StickyHeaderModule, MDBRootModule, MDBBootstrapModule, CHECKBOX_CONTROL_VALUE_ACCESSOR as ɵb, RADIO_CONTROL_VALUE_ACCESSOR as ɵa, CHECKBOX_VALUE_ACCESSOR as ɵc, CheckboxComponent as ɵd, ComponentLoaderFactory as ɵe, OnChange$1 as ɵg, PositioningService as ɵf };\n//# sourceMappingURL=angular-bootstrap-md.js.map \n",null]}
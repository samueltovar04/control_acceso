{"remainingRequest":"C:\\Lagash\\Projects\\control\\control_web\\src\\main\\web\\node_modules\\@angular-devkit\\build-optimizer\\src\\build-optimizer\\webpack-loader.js??ref--3-1!C:\\Lagash\\Projects\\control\\control_web\\src\\main\\web\\node_modules\\@agm\\core\\services\\managers\\polygon-manager.js","dependencies":[{"path":"C:\\Lagash\\Projects\\control\\control_web\\src\\main\\web\\node_modules\\@agm\\core\\services\\managers\\polygon-manager.js","mtime":499162500000},{"path":"C:\\Lagash\\Projects\\control\\control_web\\src\\main\\web\\node_modules\\cache-loader\\dist\\cjs.js","mtime":499162500000},{"path":"C:\\Lagash\\Projects\\control\\control_web\\src\\main\\web\\node_modules\\@angular-devkit\\build-optimizer\\src\\build-optimizer\\webpack-loader.js","mtime":1519266497000}],"contextDependencies":[],"result":["import { __decorate } from \"tslib\";\nimport { __metadata } from \"tslib\";\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try {\n            step(generator.next(value));\n        }\n        catch (e) {\n            reject(e);\n        } }\n        function rejected(value) { try {\n            step(generator[\"throw\"](value));\n        }\n        catch (e) {\n            reject(e);\n        } }\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __generator = (this && this.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function () { if (t[0] & 1)\n            throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function () { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f)\n            throw new TypeError(\"Generator is already executing.\");\n        while (_)\n            try {\n                if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)\n                    return t;\n                if (y = 0, t)\n                    op = [op[0] & 2, t.value];\n                switch (op[0]) {\n                    case 0:\n                    case 1:\n                        t = op;\n                        break;\n                    case 4:\n                        _.label++;\n                        return { value: op[1], done: false };\n                    case 5:\n                        _.label++;\n                        y = op[1];\n                        op = [0];\n                        continue;\n                    case 7:\n                        op = _.ops.pop();\n                        _.trys.pop();\n                        continue;\n                    default:\n                        if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {\n                            _ = 0;\n                            continue;\n                        }\n                        if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) {\n                            _.label = op[1];\n                            break;\n                        }\n                        if (op[0] === 6 && _.label < t[1]) {\n                            _.label = t[1];\n                            t = op;\n                            break;\n                        }\n                        if (t && _.label < t[2]) {\n                            _.label = t[2];\n                            _.ops.push(op);\n                            break;\n                        }\n                        if (t[2])\n                            _.ops.pop();\n                        _.trys.pop();\n                        continue;\n                }\n                op = body.call(thisArg, _);\n            }\n            catch (e) {\n                op = [6, e];\n                y = 0;\n            }\n            finally {\n                f = t = 0;\n            }\n        if (op[0] & 5)\n            throw op[1];\n        return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\nimport { Injectable, NgZone } from '@angular/core';\nimport { Observable, merge } from 'rxjs';\nimport { startWith, map, switchMap, skip } from 'rxjs/operators';\nimport { GoogleMapsAPIWrapper } from '../google-maps-api-wrapper';\nimport { createMVCEventObservable } from '../../utils/mvcarray-utils';\nvar PolygonManager = /*@__PURE__*/ (function () {\n    function PolygonManager(_mapsWrapper, _zone) {\n        this._mapsWrapper = _mapsWrapper;\n        this._zone = _zone;\n        this._polygons = new Map();\n    }\n    PolygonManager.prototype.addPolygon = function (path) {\n        var polygonPromise = this._mapsWrapper.createPolygon({\n            clickable: path.clickable,\n            draggable: path.draggable,\n            editable: path.editable,\n            fillColor: path.fillColor,\n            fillOpacity: path.fillOpacity,\n            geodesic: path.geodesic,\n            paths: path.paths,\n            strokeColor: path.strokeColor,\n            strokeOpacity: path.strokeOpacity,\n            strokeWeight: path.strokeWeight,\n            visible: path.visible,\n            zIndex: path.zIndex,\n        });\n        this._polygons.set(path, polygonPromise);\n    };\n    PolygonManager.prototype.updatePolygon = function (polygon) {\n        var _this = this;\n        var m = this._polygons.get(polygon);\n        if (m == null) {\n            return Promise.resolve();\n        }\n        return m.then(function (l) { return _this._zone.run(function () { l.setPaths(polygon.paths); }); });\n    };\n    PolygonManager.prototype.setPolygonOptions = function (path, options) {\n        return this._polygons.get(path).then(function (l) { l.setOptions(options); });\n    };\n    PolygonManager.prototype.deletePolygon = function (paths) {\n        var _this = this;\n        var m = this._polygons.get(paths);\n        if (m == null) {\n            return Promise.resolve();\n        }\n        return m.then(function (l) {\n            return _this._zone.run(function () {\n                l.setMap(null);\n                _this._polygons.delete(paths);\n            });\n        });\n    };\n    PolygonManager.prototype.getPath = function (polygon) {\n        return this._polygons.get(polygon)\n            .then(function (polygon) { return polygon.getPath().getArray(); });\n    };\n    PolygonManager.prototype.getPaths = function (polygon) {\n        return this._polygons.get(polygon)\n            .then(function (polygon) { return polygon.getPaths().getArray().map(function (p) { return p.getArray(); }); });\n    };\n    PolygonManager.prototype.createEventObservable = function (eventName, path) {\n        var _this = this;\n        return new Observable(function (observer) {\n            _this._polygons.get(path).then(function (l) {\n                l.addListener(eventName, function (e) { return _this._zone.run(function () { return observer.next(e); }); });\n            });\n        });\n    };\n    PolygonManager.prototype.createPathEventObservable = function (agmPolygon) {\n        return __awaiter(this, void 0, void 0, function () {\n            var polygon, paths, pathsChanges$;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0: return [4 /*yield*/, this._polygons.get(agmPolygon)];\n                    case 1:\n                        polygon = _a.sent();\n                        paths = polygon.getPaths();\n                        pathsChanges$ = createMVCEventObservable(paths);\n                        return [2 /*return*/, pathsChanges$.pipe(startWith({ newArr: paths.getArray() }), // in order to subscribe to them all\n                            switchMap(function (parentMVEvent) {\n                                return merge.apply(void 0, // rest parameter\n                                parentMVEvent.newArr.map(function (chMVC, index) {\n                                    return createMVCEventObservable(chMVC)\n                                        .pipe(map(function (chMVCEvent) { return ({ parentMVEvent: parentMVEvent, chMVCEvent: chMVCEvent, pathIndex: index }); }));\n                                })).pipe(startWith({ parentMVEvent: parentMVEvent, chMVCEvent: null, pathIndex: null }));\n                            }), // start the merged ob with an event signinifing change to parent\n                            skip(1), // skip the manually added event\n                            map(function (_a) {\n                                var parentMVEvent = _a.parentMVEvent, chMVCEvent = _a.chMVCEvent, pathIndex = _a.pathIndex;\n                                var retVal;\n                                if (!chMVCEvent) {\n                                    retVal = {\n                                        newArr: parentMVEvent.newArr.map(function (subArr) { return subArr.getArray().map(function (latLng) { return latLng.toJSON(); }); }),\n                                        eventName: parentMVEvent.evName,\n                                        index: parentMVEvent.index,\n                                    };\n                                    if (parentMVEvent.previous) {\n                                        retVal.previous = parentMVEvent.previous.getArray();\n                                    }\n                                }\n                                else {\n                                    retVal = {\n                                        newArr: parentMVEvent.newArr.map(function (subArr) { return subArr.getArray().map(function (latLng) { return latLng.toJSON(); }); }),\n                                        pathIndex: pathIndex,\n                                        eventName: chMVCEvent.evName,\n                                        index: chMVCEvent.index\n                                    };\n                                    if (chMVCEvent.previous) {\n                                        retVal.previous = chMVCEvent.previous;\n                                    }\n                                }\n                                return retVal;\n                            }))];\n                }\n            });\n        });\n    };\n    return PolygonManager;\n}());\nexport { PolygonManager };\n//# sourceMappingURL=polygon-manager.js.map \n",null]}